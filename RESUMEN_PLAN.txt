â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                   PLAN DE REFACTORIZACIÃ“N: DECORADORES                         â•‘
â•‘                 De Hardcodeado en Rust â†’ Definibles en Raccoon                  â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ VISIÃ“N                                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Los decoradores son FUNCIONES ESPECIALES que transforman entidades.
  Se definen en Raccoon. El usuario define TODO.

  Ejemplo:
    decorator cache(ms: int = 5000) {
        return fn(...args) {
            // lÃ³gica de cache
        }
    }

    @cache(3000)
    fn expensive() { }

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DEPENDENCIAS (3 Features Necesarias)                                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  1ï¸âƒ£  FUNCIONES ANÃ“NIMAS (2-3h)
      fn { stmts }  o  fn => expr

      Necesario para: decoradores que retornan funciones
      Complejidad: BAJA

  2ï¸âƒ£  PATTERN MATCHING (4-6h)  [depende de 1ï¸âƒ£]
      match value {
          "a" => ...,
          1..10 => ...,
          _ => ...
      }

      Necesario para: decoradores con lÃ³gica por contexto
      Complejidad: MEDIA

  3ï¸âƒ£  CLASES ANÃ“NIMAS (2-3h)  [depende de 1ï¸âƒ£]
      class extends This { ... }

      Necesario para: decoradores que extienden clases
      Complejidad: MEDIA

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TAREAS DE IMPLEMENTACIÃ“N                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

ORDEN RECOMENDADO:

  [ ] 1. Implementar Funciones AnÃ³nimas
        - Parser: fn { stmts } vs fn => expr
        - AST: AnonymousFnExpr
        - Interpreter: evaluate_anonymous_fn()

  [ ] 2. Implementar Pattern Matching
        - Parser: match expr { pattern => expr, ... }
        - AST: MatchExpr, Pattern enum
        - Interpreter: evaluate_match_expr(), matches_pattern()

  [ ] 3. Implementar Clases AnÃ³nimas
        - Parser: class { ... } sin nombre
        - AST: ClassLiteral
        - Interpreter: evaluate_class_literal()

  [ ] 4. Implementar Keyword `decorator`
        - Parser: decorator name(params) { body }
        - AST: DecoratorDefinition
        - Interpreter: execute_decorator_def()

  [ ] 5. Implementar Contexto ImplÃ­cito
        - Variables: this, context
        - Setup en interpreter cuando ejecuta decorador
        - create_context_object() helper

  [ ] 6. Refactorizar DecoratorRegistry
        - De DecoratorSpec a DecoratorFunction (almacena AST)
        - Nuevo: get_decorator(), apply_decorator()
        - Remover: DecoratorSpec, allowed_on, validaciones hardcodeadas

  [ ] 7. Implementar AplicaciÃ³n de Decoradores
        - execute_fn_decl: aplicar decoradores
        - execute_class_decl: aplicar decoradores
        - MÃ©todos, propiedades: aplicar decoradores

  [ ] 8. Remover Decorators Hardcodeados
        - Remover validaciones especÃ­ficas
        - Remover lÃ³gica de @deprecated, @cache, etc.
        - Mover a stdlib/decorators.rcc

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ CAMBIOS EN CADA MÃ“DULO                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

src/parser/mod.rs:
  + parse_anonymous_fn()
  + parse_match_expr()
  + parse_decorator_def()
  + parse_pattern()
  + Actualizar parse_primary_expr()

src/ast/nodes.rs:
  + enum Stmt { DecoratorDef(DecoratorDefinition) }
  + enum Expr { Match(MatchExpr), AnonymousFn(...), ClassLiteral(...) }
  + struct MatchExpr, MatchArm
  + struct AnonymousFnExpr
  + struct ClassLiteral
  + enum Pattern { Wildcard, Literal, Type, Range, List, Object, ... }

src/interpreter/mod.rs:
  + evaluate_match_expr()
  + evaluate_anonymous_fn()
  + evaluate_class_literal()
  + matches_pattern()
  + create_context_object()
  + apply_decorators()
  - validate_and_process_decorators() [remover]

src/interpreter/declarations.rs:
  + execute_decorator_def()
  ~ execute_fn_decl(): llamar apply_decorators()
  ~ execute_class_decl(): llamar apply_decorators()
  ~ execute_class_method(): llamar apply_decorators()
  - lÃ³gica hardcodeada de decoradores

src/runtime/decorator_registry.rs:
  âœ REFACTORIZAR COMPLETAMENTE
  - DecoratorSpec
  - DecoratorVisibility
  - allowed_on
  + DecoratorFunction { name, parameters, body }
  + fn get_decorator(&self, name: &str)
  + fn register_decorator(&mut self, def)

src/runtime/values.rs:
  Sin cambios (generalmente)

stdlib/decorators.rcc:
  NUEVO ARCHIVO
  - Definiciones de decoradores built-in
  - @deprecated, @cache, @log, @retry, etc.
  - Se cargan al inicializar stdlib

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ EJEMPLO COMPLETO: DECORADOR @cache                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

DEFINICIÃ“N (en stdlib/decorators.rcc):

  decorator cache(ms: int = 5000) {
      let store = {}
      return fn(...args) {
          let key = stringify(args)
          if (store.has(key)) return store.get(key)
          let result = this(...args)
          store.set(key, result)
          setTimeout(() => store.delete(key), ms)
          return result
      }
  }

PARSE TIME:

  decorator cache(...) { }  â†’  DecoratorDefinition
                                   â†“
                           Almacenar en DecoratorRegistry

USO:

  @cache(3000)
  fn expensive(n: int): int { ... }

RUNTIME:

  1. Parser ve FnDecl con decorators: [@cache(3000)]
  2. Interpreter.execute_fn_decl()
     a) Crear funciÃ³n original
     b) Para cada decorador en decorators:
        - Buscar "cache" en registry
        - Crear environment con:
          * this = funciÃ³n original
          * context = { type: "function", name: "expensive", ... }
          * ms = 3000
        - Ejecutar body del decorador
        - Resultado es nueva funciÃ³n (decorada)
     c) Registrar funciÃ³n decorada

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ BENEFICIOS                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  âœ… Cero boilerplate en Rust
  âœ… Decoradores son funciones normales en Raccoon
  âœ… Usuarios pueden extender sin tocar cÃ³digo Rust
  âœ… Un solo sistema de decoradores
  âœ… FFI integrado como decorador estÃ¡ndar
  âœ… CÃ³digo mÃ¡s limpio y mantenible
  âœ… Multi-contexto natural (function, method, class, property, etc.)

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ TIMELINE                                                                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Funciones AnÃ³nimas:      2-3 h    [########]
  Pattern Matching:        4-6 h    [################]
  Clases AnÃ³nimas:         2-3 h    [########]
  Decoradores:             3-4 h    [############]
  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  TOTAL:                  11-16 h

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ DOCUMENTACIÃ“N COMPLETA                                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  ğŸ“„ VISION_DECORADORES.md
     - VisiÃ³n general
     - Sintaxis final
     - Casos de uso reales

  ğŸ“„ DECORATOR_DEPENDENCIES.md
     - Detalles tÃ©cnicos de las 3 features
     - Cambios en parser, AST, interpreter
     - Ejemplos de cada feature

  ğŸ“„ Archivos que se van a crear durante implementaciÃ³n:
     - stdlib/decorators.rcc (decoradores built-in)
     - src/interpreter/expressions.rs (actualizado con match, fn, class)
     - src/parser/ (actualizado con nuevas reglas)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
