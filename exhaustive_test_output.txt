
Error EXHAUSTIVE_TEST.rcc 44:22 -> Expected expression
  42  │ try {
  43  │     // Single parameter, no parentheses, expression body
  44  │     const single = x => x * 2;
                            ^
  45  │     print("✓ Single param (x => x*2):", single(5));
  46  │ 



Error EXHAUSTIVE_TEST.rcc 72:22 -> Expected expression
  70  │ 
  71  │     // Nested arrow functions
  72  │     const nested = x => y => x + y;
                            ^
  73  │     print("✓ Nested arrows:", nested(5)(10));
  74  │ 



Error EXHAUSTIVE_TEST.rcc 75:1 -> Expected expression
  73  │     print("✓ Nested arrows:", nested(5)(10));
  74  │ 
  75  │ } catch (e) {
       ^
  76  │     print("✗ Arrow function syntax failed:", e);
  77  │ }



Error EXHAUSTIVE_TEST.rcc 77:1 -> Expected expression
  75  │ } catch (e) {
  76  │     print("✗ Arrow function syntax failed:", e);
  77  │ }
       ^
  78  │ print("");
  79  │ 



Error EXHAUSTIVE_TEST.rcc 131:23 -> Expected type
 129  │ 
 130  │     // Closure capturing
 131  │     fn makeCounter(): fn {
                             ^
 132  │         let count = 0;
 133  │         return () => {



Error EXHAUSTIVE_TEST.rcc 137:5 -> Expected expression
 135  │             return count;
 136  │         };
 137  │     }
           ^
 138  │     const counter = makeCounter();
 139  │     print("✓ Closure call 1:", counter());



Error EXHAUSTIVE_TEST.rcc 144:37 -> Expected type
 142  │ 
 143  │     // Closure with parameter
 144  │     fn makeMultiplier(factor: int): fn {
                                           ^
 145  │         return (x) => x * factor;
 146  │     }



Error EXHAUSTIVE_TEST.rcc 146:5 -> Expected expression
 144  │     fn makeMultiplier(factor: int): fn {
 145  │         return (x) => x * factor;
 146  │     }
           ^
 147  │     const times3 = makeMultiplier(3);
 148  │     print("✓ Closure with param:", times3(7));



Error EXHAUSTIVE_TEST.rcc 151:26 -> Expected type
 149  │ 
 150  │     // Nested closures
 151  │     fn outer_fn(x: int): fn {
                                ^
 152  │         return (y) => {
 153  │             return (z) => x + y + z;



Error EXHAUSTIVE_TEST.rcc 155:5 -> Expected expression
 153  │             return (z) => x + y + z;
 154  │         };
 155  │     }
           ^
 156  │     print("✓ Nested closures:", outer_fn(1)(2)(3));
 157  │ 



Error EXHAUSTIVE_TEST.rcc 158:1 -> Expected expression
 156  │     print("✓ Nested closures:", outer_fn(1)(2)(3));
 157  │ 
 158  │ } catch (e) {
       ^
 159  │     print("✗ Scope and closures failed:", e);
 160  │ }



Error EXHAUSTIVE_TEST.rcc 160:1 -> Expected expression
 158  │ } catch (e) {
 159  │     print("✗ Scope and closures failed:", e);
 160  │ }
       ^
 161  │ print("");
 162  │ 



Error EXHAUSTIVE_TEST.rcc 220:22 -> Expected expression
 218  │     // Inclusive range
 219  │     let inclusiveSum = 0;
 220  │     for (let n in 1..=5) {
                            ^
 221  │         inclusiveSum = inclusiveSum + n;
 222  │     }



Error EXHAUSTIVE_TEST.rcc 222:5 -> Expected expression
 220  │     for (let n in 1..=5) {
 221  │         inclusiveSum = inclusiveSum + n;
 222  │     }
           ^
 223  │     print("✓ Inclusive range 1..=5:", inclusiveSum);
 224  │ 



Error EXHAUSTIVE_TEST.rcc 225:1 -> Expected expression
 223  │     print("✓ Inclusive range 1..=5:", inclusiveSum);
 224  │ 
 225  │ } catch (e) {
       ^
 226  │     print("✗ Range literals failed:", e);
 227  │ }



Error EXHAUSTIVE_TEST.rcc 227:1 -> Expected expression
 225  │ } catch (e) {
 226  │     print("✗ Range literals failed:", e);
 227  │ }
       ^
 228  │ print("");
 229  │ 



Error EXHAUSTIVE_TEST.rcc 412:17 -> Expected ':' after property name
 410  │     const objWithMethod = {
 411  │         value: 10,
 412  │         getValue() {
                       ^
 413  │             return this.value;
 414  │         }



Error EXHAUSTIVE_TEST.rcc 414:9 -> Expected expression
 412  │         getValue() {
 413  │             return this.value;
 414  │         }
               ^
 415  │     };
 416  │     print("✓ Method shorthand:", objWithMethod.getValue());



Error EXHAUSTIVE_TEST.rcc 421:9 -> Expected property name or string literal
 419  │     const key = "dynamic";
 420  │     const objComputed = {
 421  │         [key]: "value",
               ^
 422  │         ["key" + "2"]: "value2"
 423  │     };



Error EXHAUSTIVE_TEST.rcc 426:1 -> Expected expression
 424  │     print("✓ Computed properties:", objComputed.dynamic, objComputed.key2);
 425  │ 
 426  │ } catch (e) {
       ^
 427  │     print("✗ Object features failed:", e);
 428  │ }



Error EXHAUSTIVE_TEST.rcc 428:1 -> Expected expression
 426  │ } catch (e) {
 427  │     print("✗ Object features failed:", e);
 428  │ }
       ^
 429  │ print("");
 430  │ 



Error EXHAUSTIVE_TEST.rcc 518:34 -> Expected ')' after method arguments
 516  │ 
 517  │     // Map
 518  │     const mapped = testArr.map(x => x * 2);
                                        ^
 519  │     print("✓ Array.map:", mapped);
 520  │ 



Error EXHAUSTIVE_TEST.rcc 522:39 -> Expected ')' after method arguments
 520  │ 
 521  │     // Filter
 522  │     const filtered = testArr.filter(x => x > 2);
                                             ^
 523  │     print("✓ Array.filter:", filtered);
 524  │ 



Error EXHAUSTIVE_TEST.rcc 530:34 -> Expected ')' after method arguments
 528  │ 
 529  │     // Find
 530  │     const found = testArr.find(x => x > 3);
                                        ^
 531  │     print("✓ Array.find:", found);
 532  │ 



Error EXHAUSTIVE_TEST.rcc 534:41 -> Expected ')' after method arguments
 532  │ 
 533  │     // Every
 534  │     const allPositive = testArr.every(x => x > 0);
                                               ^
 535  │     print("✓ Array.every:", allPositive);
 536  │ 



Error EXHAUSTIVE_TEST.rcc 538:36 -> Expected ')' after method arguments
 536  │ 
 537  │     // Some
 538  │     const hasEven = testArr.some(x => x % 2 == 0);
                                          ^
 539  │     print("✓ Array.some:", hasEven);
 540  │ 



Error EXHAUSTIVE_TEST.rcc 543:23 -> Expected ')' after method arguments
 541  │     // ForEach
 542  │     let forEachSum = 0;
 543  │     testArr.forEach(x => {
                             ^
 544  │         forEachSum = forEachSum + x;
 545  │     });



Error EXHAUSTIVE_TEST.rcc 545:5 -> Expected expression
 543  │     testArr.forEach(x => {
 544  │         forEachSum = forEachSum + x;
 545  │     });
           ^
 546  │     print("✓ Array.forEach:", forEachSum);
 547  │ 



Error EXHAUSTIVE_TEST.rcc 548:1 -> Expected expression
 546  │     print("✓ Array.forEach:", forEachSum);
 547  │ 
 548  │ } catch (e) {
       ^
 549  │     print("✗ Array methods failed:", e);
 550  │ }



Error EXHAUSTIVE_TEST.rcc 550:1 -> Expected expression
 548  │ } catch (e) {
 549  │     print("✗ Array methods failed:", e);
 550  │ }
       ^
 551  │ print("");
 552  │ 



Error EXHAUSTIVE_TEST.rcc 814:15 -> Expected '}'
 812  │ 
 813  │     // Default values in destructuring
 814  │     const { x = 10, y = 20 } = { x: 5 };
                     ^
 815  │     print("✓ Destructuring with defaults:", x, y);
 816  │ 



Error EXHAUSTIVE_TEST.rcc 817:1 -> Expected expression
 815  │     print("✓ Destructuring with defaults:", x, y);
 816  │ 
 817  │ } catch (e) {
       ^
 818  │     print("✗ Complex destructuring failed:", e);
 819  │ }



Error EXHAUSTIVE_TEST.rcc 819:1 -> Expected expression
 817  │ } catch (e) {
 818  │     print("✗ Complex destructuring failed:", e);
 819  │ }
       ^
 820  │ print("");
 821  │ 


╔══════════════════════════════════════════════════════════════╗
║  EXHAUSTIVE RACCOON LANGUAGE TEST                           ║
╚══════════════════════════════════════════════════════════════╝

═══ TEST 1: PATTERN MATCHING ═══
✓ Switch with int: one
✓ Switch with string: greeting
✓ Switch default: unknown

═══ TEST 2: ARROW FUNCTION SYNTAXES ═══

Error EXHAUSTIVE_TEST.rcc 45:41 -> Variable 'single' is not declared
  43  │     // Single parameter, no parentheses, expression body
  44  │     const single = x => x * 2;
  45  │     print("✓ Single param (x => x*2):", single(5));
                                               ^
  46  │ 
  47  │     // Single parameter with parentheses


