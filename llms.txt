Proyecto: Raccoon
Lenguaje principal: Rust (Cargo)
Prop√≥sito: Lenguaje de programaci√≥n compilado con int√©rprete/REPL escrito en Rust. Implementaci√≥n completa: lexer, parser, analizador sem√°ntico, sistema de tipos, int√©rprete con soporte async/await y stdlib escrita en Raccoon.
Estado actual: Desarrollo activo ‚Äî Fase 2 (Pattern Matching como expresi√≥n) ‚úÖ COMPLETADA con test suite exhaustivo

Resumen r√°pido (qu√© hace cada cosa)
- `Cargo.toml` ‚Äî manifest de Rust (build y dependencias). Punto de partida para `cargo build`, `cargo run`, `cargo test`.
- `src/main.rs` ‚Äî CLI y REPL. Soporta subcomandos `run` y `repl` con flags para mostrar tokens/AST y controlar la interpretaci√≥n (ver secci√≥n CLI abajo).
- `src/lib.rs` ‚Äî API p√∫blica del crate; re-exporta componentes usados por `main` y por integraciones.
- `target/` ‚Äî artefactos de compilaci√≥n generados por Cargo (no versionar).

Estructura y responsabilidades por archivo/directorio (m√°s contexto)
- `src/lexer.rs`
  - Responsabilidad: convertir texto fuente en una secuencia de `Token`.
  - Funciones/entradas clave: `Lexer::new(source: String, file: Option<String>)` y `tokenize() -> Result<Vec<Token>, LexerError>`.
  - Errores: tokens inv√°lidos, literales sin cerrar, caracteres inesperados.
  - D√≥nde cambiar: para a√±adir tokens nuevos, actualizar aqu√≠ y `tokens.rs`.

- `src/tokens.rs`
  - Contiene la enum `TokenType` y la estructura `Token` (lexema, posici√≥n, rango).
  - √ötil para formateadores, impresi√≥n en REPL y comunicaci√≥n entre lexer/parser.

- `src/parser/` (directorio)
  - Contiene el parser y probablemente varios m√≥dulos para precedencia, expresiones y declaraciones.
  - Entradas clave: `Parser::new(tokens, file)` y `parse() -> Result<Program, ParseError>`.
  - Salida: AST (nodos en `src/ast/`). Cambios en gram√°tica afectan directamente aqu√≠.

- `src/ast/`
  - Definiciones de nodos (Program, Statement, Expression, Type annotations, etc.).
  - Cuando a√±ades una nueva construcci√≥n sint√°ctica: a√±adir nodo AST aqu√≠, serializaci√≥n/Debug si necesario.

- `src/semantic_analyzer.rs`
  - Comprueba tipos, declaraciones, usos de variables, consistencia de clases/miembros.
  - Emite errores sem√°nticos con localizaci√≥n (l√≠nea/columna).
  - Puntos de cambio comunes: nuevas reglas de tipado, inferencia, coerciones.

- `src/symbol_table.rs`
  - Manejo de scopes, bindings, resoluci√≥n de identificadores.
  - Cambiar aqu√≠ si se a√±aden reglas sobre visibilidad, shadowing o namespaces.

- `src/type_system/`
  - Implementaci√≥n del sistema de tipos (representaci√≥n interna de tipos, inferencia, comprobaciones).
  - Buscar funciones para `unify`, `is_assignable_to`, y conversiones.

- `src/interpreter/`
  - Implementa `Interpreter::new(file: Option<String>)` y `interpret(program).await -> Result<Value, RuntimeError>`.
  - Aqu√≠ se ejecuta el AST: llamadas a funciones, manejo de scope en tiempo de ejecuci√≥n, async/futures si aplica.
  - Cambios de runtime (p. ej. sem√°ntica de `await`, ciclos de vida) requieren pruebas en `tests/`.

- `src/runtime/`
  - 13 m√≥dulos: valores (values.rs), ambiente (environment.rs), builtins, sistema de tipos nativo.
  - Subcarpeta `natives/` con m√≥dulos: io, math, string, array, json, time, random, http, ffi.
  - FFI integration: rust_ffi.rs, rust_ffi_modules.rs para bindeos de Rust.
  - Decoradores: decorator_registry.rs, decorators.rs para sistema de decoradores.
  - Lugar para exponer funciones nativas a `.rcc`.

- `src/analyzer/`
  - An√°lisis sem√°ntico (analyzer.rs) y an√°lisis de expresiones (expressions.rs).
  - Comprobaciones post-parse antes de la interpretaci√≥n.

- `src/stdlib/` y carga din√°mica en `src/runtime/stdlib_loader.rs`
  - Biblioteca est√°ndar para m√≥dulos como Future/Promise con m√©todos: then, catch, finally, allSettled.
  - Tipos nativas: List, Map, Set, Tuple, Range, Optional.
  - Para extender: agregar m√≥dulos en runtime/natives/ o crear nuevos archivos `.rcc`.

- `tests/` (scripts `.rcc`)
  - Contienen casos de integraci√≥n y ejemplos. Ejecutarlos manualmente con el runner o automatizarlos con `cargo test` si hay harness.

CLI y REPL (invocaci√≥n exacta encontrada en `src/main.rs`)
- Binario: `raccoon` (definido con clap)
- Subcomandos y flags:
  - `raccoon run <FILE>`
    - `--tokens` / `-t`  ‚Äî imprime tokens generados por el lexer y sale.
    - `--ast` / `-a`     ‚Äî imprime la representaci√≥n del AST parseado y sale.
    - `--no-interpret` / `-n` ‚Äî parsea (y opcionalmente imprime) pero no ejecuta el int√©rprete.
  - `raccoon repl`
    - `--tokens` / `-t`  ‚Äî muestra tokens mientras se escribe en REPL.
    - `--interpret` / `-i` ‚Äî activa la interpretaci√≥n de las entradas (por defecto true si no se especifica comando).

Ejemplos:
  pwsh> cargo run -- run tests/syntax_functions.rcc
  pwsh> cargo run -- run tests/syntax_functions.rcc --tokens
  pwsh> cargo run -- repl

(Nota: `cargo run -- <subcommand>` pasa los args al binario; tambi√©n se puede compilar primero y ejecutar `target/debug/raccoon`)

Detalles importantes detectados en `src/main.rs`
- Usa Tokio runtime con `thread_stack_size` aumentado a 256MB debido a recursi√≥n profunda (importante para an√°lisis que usan async_recursion).
- REPL usa `rustyline` con historial en `.raccoon_history` y soporta comandos internos: `.help`, `.exit`, `.clear`, `.example`.

Contracto r√°pido para LLMs (entrada/salida)
- Entrada: archivo `.rcc` o fragmento en REPL.
- Salidas:
  - Lista de `Token` (si se pide).
  - AST (estructura serializable, `Debug`/`{:#?}` en la implementaci√≥n actual).
  - Resultado de la ejecuci√≥n (valor o efectos I/O). Errores en lexer/parser/sem√°ntica/runtime con mensajes y localizaciones.

Puntos de integraci√≥n y cambios frecuentes (lista pr√°ctica)
- A√±adir token: `src/tokens.rs` + `src/lexer.rs` + tests en `tests/`.
- Cambiar gram√°tica: `src/parser/` + `src/ast/` + `src/semantic_analyzer.rs` + adaptaciones en `interpreter/`.
- Nuevas APIs nativas: `src/runtime/` y `src/stdlib/*.rcc`.

Errores y edge-cases a vigilar
- Literales multil√≠nea, templates e interpolaci√≥n ‚Äî revisar manejo en `lexer.rs` y `parser`.
- Incompatibilidades entre versiones de stdlib y runtime ‚Äî versionar la stdlib o comprobar compatibilidad al cargar.
- Codificaci√≥n de archivos (UTF-8 vs otros) ‚Äî `fs::read_to_string` asume UTF-8; a√±adir manejo para otros encodings si necesario.

D√≥nde mirar primero para entender o modificar comportamiento
1. `src/main.rs` ‚Äî flujo de entrada y flags (actualizado).  
2. `src/lexer.rs` y `src/tokens.rs` ‚Äî c√≥mo se divide el texto.  
3. `src/parser/` y `src/ast/` ‚Äî representaci√≥n del lenguaje y lugares para cambios sint√°cticos.  
4. `src/semantic_analyzer.rs` y `src/type_system/` ‚Äî reglas sem√°nticas y tipos.  
5. `src/interpreter/` y `src/runtime/` ‚Äî ejecuci√≥n y valores nativos.

Caracter√≠sticas ACTUALES del lenguaje Raccoon (Fase 2 completa)
‚úÖ Pattern matching como primera clase: match expr { pattern => ..., pattern2 => ... }
   - Tipos soportados: literales (int/string/float/bool/null), wildcard (_), variable bindings, list patterns, object patterns, nested patterns, or patterns (|)
‚úÖ Async/await y Futures/Promises API (then, catch, finally, allSettled)
‚úÖ Clases con constructores, propiedades, m√©todos, getters/setters
‚úÖ Interfaces, enums, tipos de uni√≥n e intersecci√≥n
‚úÖ Generics y type parameters
‚úÖ Destructuring (arrays y objetos con rest parameters)
‚úÖ Decoradores (sistema de decoradores implementado)
‚úÖ FFI (Foreign Function Interface) para bindeos de Rust
‚úÖ Module system con import/export
‚úÖ Type inference engine con type checking
‚úÖ Operadores null-safety: ?., ??
‚úÖ Template strings con interpolaci√≥n
‚úÖ Spread operator (...)
‚úÖ Control flow: if/else, while, do-while, for, for-in, for-of, switch, try-catch

Peque√±os consejos para LLMs que inspeccionan el repo
- Priorizar tests en `tests/` cuando se infiere comportamiento de la stdlib o compatibilidad.
- Buscar `TODO`, `FIXME` o `NOTE` en fuentes para atajos de contexto.
- Para pattern matching: ver tests/test_*.rcc con exhaustive testing (18+ tests).
- Para errores de runtime, reproducir con REPL (modo interactivo) puede dar pistas r√°pidas.
- Revisar commit 513537e para ver test suite completo de pattern matching.

ESTADO DE LOS COMMITS RECIENTES (√∫ltimos 5)
1. 513537e ‚úÖ Add exhaustive pattern matching test suite
   - 18 tests exhaustivos para pattern matching (todos pasando)
   - Cubre: int/string/float/bool/null literals, wildcards, variables, lists, objects, nested patterns

2. 77be818 üêõ Fix literal pattern matching in interpreter
   - Correcci√≥n de comparaci√≥n de literales en pattern matching (int, string, float, bool, null)
   - 12 tests de pattern matching pasando

3. 94a4079 ‚ú® Implement pattern matching as expression (Phase 2)
   - Keyword 'match' parseado como expresi√≥n
   - Pattern enum con variantes: Wildcard, Literal, Variable, List, Object, Or, Range, Type
   - Evaluaci√≥n completa de arms de match con scope binding

4. 52b75ca üìñ Documentaci√≥n: QUICK_REFERENCE actualizado (Fase 1 completa)

5. 50fee11 üîß Correcci√≥n: Funciones an√≥nimas requieren () aunque sin par√°metros
   - Sintaxis: fn() { statements } vs fn => expression

LIMPIEZA GIT RECIENTE (archivos borrados)
- ANALISIS_FFI.txt, DECORATOR_DEPENDENCIES.md, IMPLICIT_CONTEXT_DETAILS.md
- QUICK_REFERENCE.md, README_DECORADORES.md, RESUMEN_PLAN.txt, VISION_DECORADORES.md, result.md
- test_lexer_match.rcc, test_simple_match.rcc
(Limpieza de documentos temporales tras completar Fase 2)

Notas finales
- Raccoon est√° en desarrollo activo con ciclos regulares de features + testing exhaustivo
- Pattern matching es production-ready tras pruebas exhaustivas
- El repo usa git branches limpiamente con commit messages descriptivos
- Estructura modular permite agregar nuevas fases sin romper lo existente

---

Inventario de archivos bajo `src/` (lista detallada)
- Archivos ra√≠z:
  - `src/main.rs`
  - `src/lib.rs`
  - `src/lexer.rs`
  - `src/tokens.rs`
  - `src/output_style.rs`
  - `src/error.rs`
  - `src/semantic_analyzer.rs`
  - `src/symbol_table.rs`
  - `src/parser/mod.rs`

- Directorios y ficheros relevantes:
  - `src/ast/`
    - `mod.rs`, `nodes.rs`, `types.rs` ‚Äî definiciones de nodos (incluyendo Pattern enum para pattern matching)
  - `src/parser/` (7 m√≥dulos)
    - `mod.rs`, `statements.rs`, `expressions.rs`, `declarations.rs`, `types.rs`, `precedence.rs`, `utilities.rs`
    - Soporta parsing de match expressions, destructuring, generics, decorators
  - `src/interpreter/` (8 m√≥dulos, ~121k LOC en expressions.rs)
    - `mod.rs`, `expressions.rs` (core), `declarations.rs`, `control_flow.rs`, `helpers.rs`, `operators.rs`, `module_loader.rs`, `builtins.rs`
  - `src/runtime/` (13 m√≥dulos)
    - Core: `mod.rs`, `values.rs`, `environment.rs`, `builtins.rs`, `control_flow.rs`
    - FFI/Nativos: `native_bridge.rs`, `ffi.rs`, `ffi_registry.rs`, `rust_ffi.rs`, `rust_ffi_modules.rs`, `rust_natives.rs`
    - M√≥dulos: `module_system.rs`, `stdlib_loader.rs`
    - Decoradores: `decorators.rs`, `decorator_registry.rs`
    - Tipos nativos (types/): registry.rs, str_type.rs, map_type.rs, list_type.rs, int_type.rs, float_type.rs, decimal_type.rs, bool_type.rs, bigint_type.rs
    - `natives/` (9 m√≥dulos): mod.rs, io.rs, math.rs, string.rs, array.rs, json.rs, time.rs, random.rs, http.rs, output.rs, ffi.rs
  - `src/analyzer/`
    - `mod.rs`, `analyzer.rs`, `expressions.rs` ‚Äî an√°lisis sem√°ntico post-parse
  - `src/type_system/` (5 m√≥dulos, ~951 LOC)
    - `mod.rs`, `checker.rs`, `inference.rs`, `resolver.rs`, `substitutor.rs`

Cantidad observada: ~65+ ficheros / rutas (c√≥digo fuente, m√≥dulos y subm√≥dulos).

Firmas p√∫blicas (extracto) ‚Äî funciones/estructuras/exports clave encontradas
Nota: listado simplificado para lectura r√°pida; hay muchas funciones privadas adicionales en cada archivo.

- `src/lexer.rs`
  - pub struct Lexer { ... }
  - pub fn new(source: String, file: Option<String>) -> Self
  - pub fn tokenize(&mut self) -> Result<Vec<Token>, RaccoonError>

- `src/tokens.rs`
  - pub type Position = (usize, usize)
  - pub struct Range { pub fn new(start: Position, end: Position) -> Self }
  - pub enum TokenType { ... } (lista de tokens p√∫blicamente disponible)
  - pub struct Token { pub fn new(token_type: TokenType, value: String, lexeme: String, position: Position, range: Range) -> Self }
  - pub enum BinaryOperator { ... }
  - pub enum UnaryOperator { ... }
  - pub enum AccessModifier { Public, Private, Protected }

- `src/parser/mod.rs`
  - pub struct Parser { tokens: Vec<Token>, file: Option<String>, current: usize }
  - pub fn new(tokens: Vec<Token>, file: Option<String>) -> Self
  - pub fn parse(&mut self) -> Result<Program, RaccoonError>

- `src/interpreter/mod.rs`
  - pub enum InterpreterResult { Value(RuntimeValue), Return(RuntimeValue), Break, Continue }
  - pub struct Interpreter { pub file: Option<String>, environment: Environment, ... }
  - pub fn new(file: Option<String>) -> Self
  - pub async fn interpret(&mut self, program: &Program) -> Result<RuntimeValue, RaccoonError>

- `src/runtime/mod.rs` (re-exports clave)
  - pub mod builtins; pub use builtins::setup_builtins
  - pub use environment::Environment
  - pub use ffi_registry::FFIRegistry
  - pub use native_bridge::NativeBridge
  - pub use stdlib_loader::StdLibLoader
  - pub use types::registry::TypeRegistry
  - pub use values::*

- `src/type_system/mod.rs` (re-exports)
  - pub use checker::TypeChecker
  - pub use inference::TypeInferenceEngine
  - pub use resolver::TypeResolver
  - pub use substitutor::TypeSubstitutor

C√≥mo a√±ad√≠ esto
- He inspeccionado `src/` recursivamente y le√≠ los archivos clave (`lexer.rs`, `tokens.rs`, `parser/mod.rs`, `interpreter/mod.rs`, `runtime/mod.rs`, `type_system/mod.rs`) para extraer firmas p√∫blicas y los reexports m√°s importantes.

ROADMAP futuro (basado en estado actual)
- Fase 3: Pattern matching guards (when conditions en patterns)
- Completar type system: conditional types, mapped types
- Expandir stdlib: m√°s m√≥dulos de utilidades
- Optimizaciones del compilador
- Mejorar documentaci√≥n y tutoriales

Pr√≥ximas tareas pr√°cticas
- Revisar tests/test_*.rcc para entender uso real de features
- Ejecutar `cargo build` para verificar compilaci√≥n en cambios
- Para debugging: usar `cargo run -- run <file.rcc> --tokens` o `--ast`
- A√±adir nuevas pruebas en `tests/` antes de implementar features

