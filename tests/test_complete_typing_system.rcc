// ============================================================
// COMPREHENSIVE TYPE SYSTEM TEST - TYPESCRIPT STYLE + NULLABLE SUGAR
// Raccoon Type System: ? goes AFTER the type, not the identifier
// ============================================================

print("=== RACCOON TYPE SYSTEM COMPREHENSIVE TEST ===\n");

// ============================================================
// 1. PRIMITIVE TYPES
// ============================================================
print("1. PRIMITIVE TYPES");
let num: int = 42;
let text: str = "hello";
let flag: bool = true;
let floating: float = 3.14;
let decimal_num: decimal = 123.45;
let nothing: void;
print("✓ All primitive types working\n");

// ============================================================
// 2. NULLABLE TYPES (SUGAR SYNTAX: Type?)
// Syntax: let x: Type? = value
// The ? comes AFTER the type name, not after the identifier
// ============================================================
print("2. NULLABLE TYPES (Custom Sugar Syntax)");
let nullable_string: str? = null;
let nullable_int: int? = 42;
let nullable_float: float? = null;
let nullable_bool: bool? = true;
let nullable_decimal: decimal? = 99.99;
print("✓ Nullable types working with Type? syntax\n");

// ============================================================
// 3. ARRAYS
// ============================================================
print("3. ARRAYS");
let numbers: int[] = [1, 2, 3];
let strings: str[] = ["a", "b", "c"];
let nullable_strings: str?[] = ["hello", null, "world"];
let empty_array: int[] = [];
print("✓ Arrays of primitives and nullable types working\n");

// ============================================================
// 4. TUPLES
// ============================================================
print("4. TUPLES");
type Coordinate = [int, int];
type RGB = [int, int, int];
type PersonData = [str, int];
type MixedTuple = [str, int, bool];

let coord: Coordinate = [10, 20];
let color: RGB = [255, 128, 0];
let person: PersonData = ["Alice", 30];
let mixed: MixedTuple = ["test", 42, true];
print("✓ Tuples working correctly\n");

// ============================================================
// 5. UNION TYPES
// ============================================================
print("5. UNION TYPES");
type StringOrNumber = str | int;
type Status = str | int | bool;
type MaybeString = str | null;
type MultiType = int | str | bool | float;

let val1: StringOrNumber = "hello";
let val2: StringOrNumber = 42;
let stat: Status = true;
let maybe: MaybeString = null;
let multi: MultiType = 3.14;
print("✓ Union types working\n");

// ============================================================
// 6. INTERSECTION TYPES
// ============================================================
print("6. INTERSECTION TYPES (&)");
type HasName = { name: str };
type HasAge = { age: int };
type HasEmail = { email: str };
type FullPerson = HasName & HasAge;
type SuperPerson = HasName & HasAge & HasEmail;
print("✓ Intersection types defined successfully\n");

// ============================================================
// 7. OBJECT INLINE TYPES WITH OPTIONAL PROPERTIES
// ============================================================
print("7. OBJECT TYPES WITH OPTIONAL PROPERTIES");
type User = {
    id: int,
    name: str,
    email: str?,
    phone: str?,
    verified: bool?
};

type Config = {
    readonly host: str,
    readonly port: int,
    readonly timeout: int?,
    retries: int
};

let user1: User = {
    id: 1,
    name: "Alice"
};

let user2: User = {
    id: 2,
    name: "Bob",
    email: "bob@example.com",
    phone: "+1234567890",
    verified: true
};

let config: Config = {
    host: "localhost",
    port: 3000,
    retries: 3
};

print("✓ Object types with optional properties working\n");

// ============================================================
// 8. READONLY TYPES
// ============================================================
print("8. READONLY TYPES");
type ReadonlyString = readonly str;
type ReadonlyNumber = readonly int;
type ReadonlyArray = readonly int[];
type ImmutableConfig = readonly { host: str, port: int };

let immutable_text: ReadonlyString = "constant";
let immutable_num: ReadonlyNumber = 42;
let immutable_array: ReadonlyArray = [1, 2, 3];
print("✓ Readonly types working\n");

// ============================================================
// 9. ENUMERATIONS
// ============================================================
print("9. ENUM TYPES");
enum Color {
    Red = 0,
    Green = 1,
    Blue = 2
}

enum Direction {
    Up = "UP",
    Down = "DOWN",
    Left = "LEFT",
    Right = "RIGHT"
}

let my_color: Color = Color.Red;
let my_direction: Direction = Direction.Up;
print("✓ Enum types working\n");

// ============================================================
// 10. CLASS TYPES WITH INHERITANCE
// ============================================================
print("10. CLASS TYPES");
class Animal {
    public name: str;
    private age: int;

    constructor(name: str, age: int) {
        this.name = name;
        this.age = age;
    }

    public getName(): str {
        return this.name;
    }

    public getAge(): int {
        return this.age;
    }
}

class Dog extends Animal {
    public breed: str;

    constructor(name: str, age: int, breed: str) {
        super(name, age);
        this.breed = breed;
    }
}

let dog: Dog = new Dog("Buddy", 5, "Labrador");
print("✓ Classes with inheritance working\n");

// ============================================================
// 11. INTERFACE TYPES
// ============================================================
print("11. INTERFACE TYPES");
interface Drawable {
    draw(): void;
    getColor(): str;
}

interface Resizable {
    resize(width: int, height: int): void;
    getSize(): [int, int];
}
print("✓ Interface types working\n");

// ============================================================
// 12. FUNCTION TYPES (Type Declarations)
// ============================================================
print("12. FUNCTION TYPES");
type MathOp = (a: int, b: int) => int;
type StringTransform = (input: str) => str;
type AsyncCallback = (data: str?) => void;

let add: MathOp = (a, b) => a + b;
let upper: StringTransform = (s) => s;
print("✓ Function types working\n");

// ============================================================
// 13. FUNCTION DECLARATIONS WITH TYPE ANNOTATIONS
// ============================================================
print("13. FUNCTION DECLARATIONS WITH TYPES");
fn add_numbers(a: int, b: int): int {
    return a + b;
}

fn greet(name: str): str {
    return "Hello, " + name;
}

fn process_data(value: str): void {
    print(value);
}
print("✓ Function declarations with type annotations working\n");

// ============================================================
// 14. OPTIONAL PARAMETERS (NEW FEATURE - Type? in params)
// ============================================================
print("14. OPTIONAL PARAMETERS (param?: Type)");
fn optional_param(name: str, age?: int): void {
    print(name);
}

fn multiple_optional(required: str, opt1?: int, opt2?: str): void {
    print(required);
}

fn callback_style(
    data: str,
    onSuccess?: (result: str) => void,
    onError?: (error: str) => void
): void {
    print(data);
}

optional_param("Alice");
optional_param("Bob", 30);
multiple_optional("test");
multiple_optional("test", 42);
multiple_optional("test", 42, "extra");
print("✓ Optional parameters working\n");

// ============================================================
// 15. ARROW FUNCTIONS WITH TYPE ANNOTATIONS
// ============================================================
print("15. ARROW FUNCTIONS WITH TYPES");
let double = (x: int): int => x * 2;
let concat = (a: str, b: str): str => a + b;
let process = (value: int): int => value + 1;
print("✓ Arrow functions with type annotations working\n");

// ============================================================
// 16. COMPLEX NESTED OBJECT STRUCTURES
// ============================================================
print("16. COMPLEX NESTED STRUCTURES");
type ApiResponse = {
    status: int,
    statusText: str,
    data: str?,
    error: {
        code: int,
        message: str,
        details: str?
    }?,
    metadata: {
        timestamp: str,
        version: str
    }
};

type NestedConfig = {
    database: {
        host: str,
        port: int,
        credentials: {
            user: str,
            password: str
        }?
    },
    logging: {
        level: str,
        file: str?
    }
};
print("✓ Complex nested structures working\n");

// ============================================================
// 17. TYPE ALIASES WITH UNIONS AND INTERSECTIONS
// ============================================================
print("17. TYPE ALIASES");
type Response = User | str | int | null;
type OptionalUser = User | null;
type RequiredFields = HasName & HasAge;
type FlexibleValue = str | int | bool;
print("✓ Type aliases with unions and intersections working\n");

// ============================================================
// 18. NULLABLE IN DIFFERENT CONTEXTS
// ============================================================
print("18. NULLABLE TYPES IN DIFFERENT CONTEXTS");
let nullable_in_union: str? = null;
let nullable_in_array: str?[] = ["a", null, "b"];
let nullable_in_object: { value: str? } = { value: null };
let nullable_return: str? = null;
print("✓ Nullable types in different contexts working\n");

// ============================================================
// 19. EXECUTION AND FUNCTIONALITY TEST
// ============================================================
print("19. EXECUTION TEST\n");

let result = add_numbers(5, 3);
print("add_numbers(5, 3) = " + result);

let greeting = greet("World");
print("greet('World') = " + greeting);

let doubled = double(21);
print("double(21) = " + doubled);

let concat_result = concat("Hello, ", "Raccoon!");
print("concat('Hello, ', 'Raccoon!') = " + concat_result);

print("dog.getName() = " + dog.getName());
print("dog.breed = " + dog.breed);

print("\n=== COMPLETE TYPE SYSTEM TEST SUMMARY ===");
print("✓ All TypeScript-style features working");
print("✓ Nullable sugar syntax (Type?) working");
print("✓ Optional parameters working");
print("✓ Optional object properties working");
print("✓ Complex nested types working");
print("✓ Unions and intersections working");
print("✓ Readonly types working");
print("✓ Classes and inheritance working");
print("✓ Interfaces working");
print("✓ Enums working");
print("✓ Arrow functions working");
print("\nRaccoon Type System: FULLY OPERATIONAL!");
