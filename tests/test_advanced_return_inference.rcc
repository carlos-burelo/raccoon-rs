// Test: Advanced return type inference

// Test 1: Nested function calls
fn double(x: int) {
    return x * 2;
}

fn quadruple(x: int) {
    return double(double(x));
}

// Test 2: Conditional returns with different numeric types
fn calculate(flag: bool) {
    if (flag) {
        return 42;
    } else {
        return 3.14;
    }
}

// Test 3: List return type inference
fn getNumbers() {
    return [1, 2, 3, 4, 5];
}

// Test 4: Empty return (void)
fn doNothing() {
    let x = 5;
    // no return statement
}

// Test 5: Early returns
fn checkValue(x: int) {
    if (x < 0) {
        return "negative";
    }
    if (x == 0) {
        return "zero";
    }
    return "positive";
}

// Testing
print("double(5) = " + double(5));
print("quadruple(3) = " + quadruple(3));
print("calculate(true) = " + calculate(true));
print("calculate(false) = " + calculate(false));
print("getNumbers() = " + getNumbers());
print("checkValue(-5) = " + checkValue(-5));
print("checkValue(0) = " + checkValue(0));
print("checkValue(10) = " + checkValue(10));

let result = doNothing();
print("doNothing() = " + result);
