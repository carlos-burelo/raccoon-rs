print("ü¶ù === COMPREHENSIVE DECORATORS TEST ===")


print("‚úÖ Test 1: Basic Function Decorator")

fn log(targetType: str, targetName: str): void {
    print(`  [DECORATOR] Applied to ${targetType}: ${targetName}`)
}

@log
fn greet(name: str): str {
    return "Hello, " + name
}

let result1: str = greet("Alice")
print(`  Result: ${result1}`)





print("‚úÖ Test 2: Function Decorator with Arguments")

fn trace(message: str): void {
    print(`  [TRACE] ${message}`)
}

@trace("This function calculates sum")
fn add(a: int, b: int): int {
    return a + b
}

let sum: int = add(5, 3)
print(`  Sum: ${sum}`)





print("‚úÖ Test 3: Class Decorator")

fn classLogger(targetType: str, targetName: str): void {
    print(`  [CLASS DECORATOR] Registering class: ${targetName}`)
}

@classLogger
class User {
    name: str
    
    constructor(name: str) {
        this.name = name
    }
    
    greet(): str {
        return "Hello, " + this.name
    }
}

let user: User = new User("Bob")
print(`  User greeting: ${user.greet()}`)





print("‚úÖ Test 4: Multiple Decorators on Function")

fn decorator1(): void {
    print("  [DECORATOR 1] Applied")
}

fn decorator2(): void {
    print("  [DECORATOR 2] Applied")
}

@decorator1
@decorator2
fn multiDecorated(): str {
    return "Function with multiple decorators"
}

let result2: str = multiDecorated()
print(`  Result: ${result2}`)





print("‚úÖ Test 5: Decorator with Multiple Arguments")

fn validate(minValue: int, maxValue: int): void {
    print(`  [VALIDATOR] Range: ${minValue} to ${maxValue}`)
}

@validate(0, 100)
fn percentage(value: int): str {
    return value + "%"
}

let pct: str = percentage(75)
print(`  Percentage: ${pct}`)





print("‚úÖ Test 6: Class Decorator with Arguments")

fn entity(tableName: str): void {
    print(`  [ENTITY] Table: ${tableName}`)
}

@entity("users")
class Person {
    name: str
    age: int
    
    constructor(name: str, age: int) {
        this.name = name
        this.age = age
    }
    
    getInfo(): str {
        return this.name + " is " + this.age + " years old"
    }
}

let person: Person = new Person("Charlie", 30)
print(`  ${person.getInfo()}`)





print("‚úÖ Test 7: Performance Tracking Decorator")

fn benchmark(label: str): void {
    print(`  [BENCHMARK] Tracking performance for: ${label}`)
}

@benchmark("fibonacci calculation")
fn fibonacci(n: int): int {
    if (n <= 1) {
        return n
    }
    return fibonacci(n - 1) + fibonacci(n - 2)
}

let fib: int = fibonacci(6)
print(`  Fibonacci(6) = ${fib}`)





print("‚úÖ Test 8: Metadata Decorator")

fn metadata(version: str, author: str): void {
    print(`  [METADATA] Version: ${version}, Author: ${author}`)
}

@metadata("1.0.0", "Raccoon Team")
fn processData(data: str): str {
    return "Processed: " + data
}

let processed: str = processData("test data")
print(`  ${processed}`)





print("‚úÖ Test 9: Authorization Decorator")

fn requiresAuth(role: str): void {
    print(`  [AUTH] Requires role: ${role}`)
}

@requiresAuth("admin")
fn deleteUser(userId: int): str {
    return "Deleted user " + userId
}

let deleteResult: str = deleteUser(123)
print(`  ${deleteResult}`)





print("‚úÖ Test 10: Caching Decorator")

fn cached(ttl: int): void {
    print(`  [CACHE] TTL: ${ttl} seconds`)
}

@cached(300)
fn expensiveOperation(input: str): str {
    return "Result for: " + input
}

let cacheResult: str = expensiveOperation("query")
print(`  ${cacheResult}`)





print("‚úÖ Test 11: Decorator on Inherited Class")

fn serializable(): void {
    print("  [SERIALIZABLE] Class can be serialized")
}

@serializable
class Animal {
    name: str
    
    constructor(name: str) {
        this.name = name
    }
}

class Dog extends Animal {
    breed: str
    
    constructor(name: str, breed: str) {
        super(name)
        this.breed = breed
    }
}

let dog: Dog = new Dog("Rex", "Labrador")
print(`  Dog: ${dog.name}, Breed: ${dog.breed}`)





print("‚úÖ Test 12: Deprecation Decorator")

fn deprecated(message: str): void {
    print(`  [DEPRECATED] ${message}`)
}

@deprecated("Use newFunction() instead")
fn oldFunction(): str {
    return "This is old"
}

let oldResult: str = oldFunction()
print(`  ${oldResult}`)





print("‚úÖ Test 13: Retry Decorator")

fn retry(maxAttempts: int): void {
    print(`  [RETRY] Max attempts: ${maxAttempts}`)
}

@retry(3)
fn unreliableOperation(): str {
    return "Operation completed"
}

let retryResult: str = unreliableOperation()
print(`  ${retryResult}`)





print("‚úÖ Test 14: Type Validation Decorator")

fn validateInput(paramType: str): void {
    print(`  [VALIDATE] Parameter type: ${paramType}`)
}

@validateInput("string")
fn processString(input: str): str {
    return "Processed: " + input
}

let validatedResult: str = processString("test")
print(`  ${validatedResult}`)





print("‚úÖ Test 15: Multiple Class Decorators")

fn injectable(): void {
    print("  [INJECTABLE] Class is injectable")
}

fn component(name: str): void {
    print(`  [COMPONENT] Component name: ${name}`)
}

@injectable
@component("UserService")
class UserService {
    serviceName: str
    
    constructor() {
        this.serviceName = "User Service"
    }
    
    getUsers(): str {
        return "Getting users from " + this.serviceName
    }
}

let service: UserService = new UserService()
print(`  ${service.getUsers()}`)





print("üéâ === ALL DECORATOR TESTS PASSED ===")

print("‚úÖ Basic function decorator")
print("‚úÖ Function decorator with arguments")
print("‚úÖ Class decorator")
print("‚úÖ Multiple decorators on function")
print("‚úÖ Decorator with multiple arguments")
print("‚úÖ Class decorator with arguments")
print("‚úÖ Performance tracking decorator")
print("‚úÖ Metadata decorator")
print("‚úÖ Authorization decorator")
print("‚úÖ Caching decorator")
print("‚úÖ Decorator on inherited class")
print("‚úÖ Deprecation decorator")
print("‚úÖ Retry decorator")
print("‚úÖ Type validation decorator")
print("‚úÖ Multiple class decorators")

print("ü¶ù Raccoon Decorators: FULLY FUNCTIONAL!")
