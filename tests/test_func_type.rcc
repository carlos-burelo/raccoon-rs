// Comprehensive test for the 'func' type in Raccoon

print("=== FUNC TYPE TESTS ===");
print("");

// Test 1: Basic func type assignment
print("[ 1 ] Basic func type assignment");

fn greet(name: str): str {
    return "Hello, " + name;
}

let myFunction: func = greet;
print("  Result: " + myFunction("Alice"));
print("");

// Test 2: func as parameter
print("[ 2 ] func as function parameter");

fn applyFunction(f: func, value: int): int {
    return f(value);
}

fn square(x: int): int {
    return x * x;
}

fn double(x: int): int {
    return x * 2;
}

let result1: int = applyFunction(square, 5);
let result2: int = applyFunction(double, 5);

print("  square(5) = " + result1.toStr());
print("  double(5) = " + result2.toStr());
print("");

// Test 3: func in arrays
print("[ 3 ] Arrays of func");

let operations: func[] = [square, double];
let value: int = 3;

print("  Applying operations to " + value.toStr() + ":");
print("    operations[0](3) = " + operations[0](value).toStr());
print("    operations[1](3) = " + operations[1](value).toStr());
print("");

// Test 4: func with arrow functions
print("[ 4 ] func with arrow functions");

let add: func = (a: int, b: int) => a + b;
let subtract: func = (a: int, b: int) => a - b;

print("  add(10, 5) = " + add(10, 5).toStr());
print("  subtract(10, 5) = " + subtract(10, 5).toStr());
print("");

// Test 5: func returning func
print("[ 5 ] func returning func");

fn getOperation(op: str): func {
    if (op == "add") {
        fn adder(a: int, b: int): int {
            return a + b;
        }
        return adder;
    } else {
        fn multiplier(a: int, b: int): int {
            return a * b;
        }
        return multiplier;
    }
}

let addOp: func = getOperation("add");
let mulOp: func = getOperation("mul");

print("  addOp(4, 3) = " + addOp(4, 3).toStr());
print("  mulOp(4, 3) = " + mulOp(4, 3).toStr());
print("");

// Test 6: func with different return types
print("[ 6 ] func with different return types");

fn toString(x: int): str {
    return x.toStr();
}

fn toBool(x: int): bool {
    return x > 0;
}

let converter1: func = toString;
let converter2: func = toBool;

print("  toString(42) = " + converter1(42));
print("  toBool(5) = " + converter2(5).toStr());
print("  toBool(-1) = " + converter2(-1).toStr());
print("");

// Test 7: func with map, filter, reduce
print("[ 7 ] func with higher-order array methods");

let numbers: int[] = [1, 2, 3, 4, 5];

let increment: func = (n: int) => n + 1;
let isEven: func = (n: int) => n % 2 == 0;
let sum: func = (acc: int, n: int) => acc + n;

print("  Original: " + numbers.toStr());
print("  Mapped (increment): " + numbers.map(increment).toStr());
print("  Filtered (isEven): " + numbers.filter(isEven).toStr());
print("  Reduced (sum): " + numbers.reduce(sum, 0).toStr());
print("");

// Test 8: Multiple func variables
print("[ 8 ] Multiple func variables");

let addFunc: func = (a: int, b: int) => a + b;
let subFunc: func = (a: int, b: int) => a - b;
let mulFunc: func = (a: int, b: int) => a * b;

print("  addFunc(10, 5) = " + addFunc(10, 5).toStr());
print("  subFunc(10, 5) = " + subFunc(10, 5).toStr());
print("  mulFunc(10, 5) = " + mulFunc(10, 5).toStr());
print("");

// Test 9: func with async functions
print("[ 9 ] func with async functions");

async fn fetchData(id: int): str {
    return "Data_" + id.toStr();
}

let fetcher: func = fetchData;
let dataFuture = fetcher(123);
let data: str = await dataFuture;

print("  Async result: " + data);
print("");

print("==================================================");
print("âœ… ALL FUNC TYPE TESTS PASSED");
print("==================================================");
print("");
print("The 'func' type works as a generic function type!");
print("It can represent any function signature dynamically.");
