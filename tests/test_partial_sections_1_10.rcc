




print("╔════════════════════════════════════════════════════════════════╗")
print("║     RACCOON COMPLETE SYNTAX & SEMANTICS TEST                  ║")
print("╚════════════════════════════════════════════════════════════════╝")

let testsPassed: int = 0
let testsFailed: int = 0




print("\n[1] PRIMITIVE TYPES & LITERALS")


let testInt: int = 42
let testNegative: int = -100
let testLargeInt: int = 999999999
print(`  ✓ Integer literals: ${testInt}, ${testNegative}, ${testLargeInt}`)


let testFloat: float = 3.14159
let testNegFloat: float = -2.5
let testScientific: float = 1.5
print(`  ✓ Float literals: ${testFloat}, ${testNegFloat}, ${testScientific}`)


let testStr: str = "hello world"
let testEmptyStr: str = ""
let testEscaped: str = "line1\nline2"
print(`  ✓ String literals: ${testStr}, empty="${testEmptyStr}"`)


let testTrue: bool = true
let testFalse: bool = false
print(`  ✓ Boolean literals: ${testTrue}, ${testFalse}`)


let testNull: int? = null
print(`  ✓ Null literal: ${testNull}`)


let name: str = "Raccoon"
let version: int = 1
let testTemplate: str = `Language: ${name}, Version: ${version}`
print(`  ✓ Template strings: ${testTemplate}`)

testsPassed = testsPassed + 6




print("\n[2] OPERATORS")


let a: int = 10
let b: int = 3
let add: int = a + b
let sub: int = a - b
let mul: int = a * b
let div: int = a / b
let mod: int = a % b
let exp: int = 2 ** 3
print(`  ✓ Arithmetic: +=${add}, -=${sub}, *=${mul}, /=${div}, %=${mod}, **=${exp}`)


let cmpEq: bool = a == b
let cmpNeq: bool = a != b
let cmpLt: bool = a < b
let cmpGt: bool = a > b
let cmpLte: bool = a <= b
let cmpGte: bool = a >= b
print(`  ✓ Comparison: ==${cmpEq}, !=${cmpNeq}, <${cmpLt}, >${cmpGt}`)


let logAnd: bool = true && false
let logOr: bool = true || false
let logNot: bool = !true
print(`  ✓ Logical: &&=${logAnd}, ||=${logOr}, !=${logNot}`)


let bit1: int = 5
let bit2: int = 3
let bitAnd: int = bit1 & bit2
let bitOr: int = bit1 | bit2
let bitXor: int = bit1 ^ bit2
let bitNot: int = ~bit1
let bitLeft: int = bit1 << 1
let bitRight: int = bit1 >> 1
let bitURight: int = bit1 >>> 1
print(`  ✓ Bitwise: &=${bitAnd}, |=${bitOr}, ^=${bitXor}, ~=${bitNot}`)
print(`    Shifts: <<=${bitLeft}, >>=${bitRight}, >>>=${bitURight}`)


let asgnVal: int = 10
asgnVal += 5
asgnVal -= 3
asgnVal *= 2
asgnVal /= 4
asgnVal %= 3
print(`  ✓ Assignment operators: result=${asgnVal}`)


let bitVal: int = 10
bitVal &= 7
bitVal |= 2
bitVal ^= 1
bitVal <<= 1
bitVal >>= 1
bitVal >>>= 1
bitVal **= 2
print(`  ✓ Compound bitwise assignment: result=${bitVal}`)


let incVal: int = 5
incVal++
let postInc: int = incVal
++incVal
let preInc: int = incVal
incVal--
let postDec: int = incVal
--incVal
let preDec: int = incVal
print(`  ✓ Inc/Dec: post++=${postInc}, ++pre=${preInc}, post--=${postDec}, --pre=${preDec}`)


let rangeVals: int[] = 1..5
print(`  ✓ Range operator: ${rangeVals}`)


let nullVal: int? = null
let coalescedVal: int = nullVal ?? 42
print(`  ✓ Null coalescing: ${coalescedVal}`)


let ternaryResult: int = true ? 10 : 20
print(`  ✓ Ternary operator: ${ternaryResult}`)

testsPassed = testsPassed + 10




print("\n[3] VARIABLES & CONSTANTS")


let varLet: int = 100
let varWithType: str = "typed"
let varInferred: int = 42
print(`  ✓ Let declarations: ${varLet}, ${varWithType}, ${varInferred}`)


const constVal: int = 999
const constStr: str = "immutable"
print(`  ✓ Const declarations: ${constVal}, ${constStr}`)


let shadowVar: int = 1
{
    let shadowVar: int = 2
    print(`  ✓ Variable shadowing: inner=${shadowVar}`)
}
print(`    outer=${shadowVar}`)

testsPassed = testsPassed + 3




print("\n[4] CONTROL FLOW")


let ifVal: int = 10
if (ifVal > 5) {
    print("  ✓ If statement: condition true")
}


if (ifVal < 5) {
    print("  ✗ If-else: wrong branch")
} else {
    print("  ✓ If-else statement: else branch")
}


let grade: int = 85
if (grade >= 90) {
    print("  Grade: A")
} else if (grade >= 80) {
    print("  ✓ If-else-if chain: grade B")
} else if (grade >= 70) {
    print("  Grade: C")
} else {
    print("  Grade: F")
}


let whileCount: int = 0
while (whileCount < 3) {
    whileCount = whileCount + 1
}
print(`  ✓ While loop: iterations=${whileCount}`)


let forSum: int = 0
for (let i: int = 0; i < 5; i = i + 1) {
    forSum = forSum + i
}
print(`  ✓ For loop: sum=${forSum}`)


let forInSum: int = 0
for (let val: int in 1..4) {
    forInSum = forInSum + val
}
print(`  ✓ For-in loop: sum=${forInSum}`)


let breakCount: int = 0
while (breakCount < 10) {
    breakCount = breakCount + 1
    if (breakCount == 3) {
        break
    }
}
print(`  ✓ Break statement: stopped at ${breakCount}`)


let continueSum: int = 0
let continueIdx: int = 0
while (continueIdx < 5) {
    continueIdx = continueIdx + 1
    if (continueIdx == 3) {
        continue
    }
    continueSum = continueSum + continueIdx
}
print(`  ✓ Continue statement: sum=${continueSum} (skipped 3)`)

testsPassed = testsPassed + 8




print("\n[5] FUNCTIONS")


fn basicFunc(): int {
    return 42
}
let basicResult: int = basicFunc()
print(`  ✓ Basic function: ${basicResult}`)


fn addFunc(x: int, y: int): int {
    return x + y
}
let addResult: int = addFunc(10, 20)
print(`  ✓ Function with params: ${addResult}`)


fn optionalFunc(x: int, y?: int): int {
    return x
}
let optResult1: int = optionalFunc(5)
let optResult2: int = optionalFunc(5, 10)
print(`  ✓ Optional parameters: ${optResult1}, ${optResult2}`)


fn defaultFunc(x: int, y: int = 10): int {
    return x + y
}
let defResult1: int = defaultFunc(5)
let defResult2: int = defaultFunc(5, 20)
print(`  ✓ Default parameters: ${defResult1}, ${defResult2}`)


fn restFunc(...args: int[]): int {
    let sum: int = 0
    for (let val: int in args) {
        sum = sum + val
    }
    return sum
}
let restResult: int = restFunc(1, 2, 3, 4, 5)
print(`  ✓ Rest parameters: ${restResult}`)


let arrowBasic: (int, int) => int = (x: int, y: int): int => x + y
let arrowResult: int = arrowBasic(5, 7)
print(`  ✓ Arrow function: ${arrowResult}`)


let arrowExpr: (int) => int = (x: int): int => x * 2
let arrowExprResult: int = arrowExpr(5)
print(`  ✓ Arrow expression: ${arrowExprResult}`)


let arrowBlock: (int) => int = (x: int): int => {
    let temp: int = x * 2
    return temp + 1
}
let arrowBlockResult: int = arrowBlock(5)
print(`  ✓ Arrow block: ${arrowBlockResult}`)


fn higherOrder(f: (int) => int, x: int): int {
    return f(x)
}
let hoResult: int = higherOrder(arrowExpr, 10)
print(`  ✓ Higher-order function: ${hoResult}`)


fn factorial(n: int): int {
    if (n <= 1) {
        return 1
    }
    return n * factorial(n - 1)
}
let factResult: int = factorial(5)
print(`  ✓ Recursive function: ${factResult}`)


fn namedArgsFunc(x: int, y: int, z: int): int {
    return x + y + z
}
let namedResult: int = namedArgsFunc(x: 1, y: 2, z: 3)
print(`  ✓ Named arguments: ${namedResult}`)

testsPassed = testsPassed + 11




print("\n[6] ARRAYS & COLLECTIONS")


let intArray: int[] = [1, 2, 3, 4, 5]
let strArray: str[] = ["a", "b", "c"]
let emptyArray: int[] = []
print(`  ✓ Array literals: ${intArray}, ${strArray}`)


let arr: int[] = [10, 20, 30]
let arrElem: int = arr[1]
print(`  ✓ Array indexing: ${arrElem}`)


arr[0] = 99
print(`  ✓ Array assignment: ${arr}`)


let arrLen: int = arr.length()
print(`  ✓ Array length: ${arrLen}`)


arr.push(40)
print(`  ✓ Array push: ${arr}`)


let popped: int = arr.pop()
print(`  ✓ Array pop: ${popped}, remaining: ${arr}`)


let nested: int[][] = [[1, 2], [3, 4]]
let nestedElem: int = nested[0][1]
print(`  ✓ Nested arrays: ${nestedElem}`)


let spread1: int[] = [1, 2]
let spread2: int[] = [3, 4]
let spreadResult: int[] = [...spread1, ...spread2]
print(`  ✓ Array spread: ${spreadResult}`)

testsPassed = testsPassed + 8




print("\n[7] OBJECTS & MAPS")


let obj: any = { x: 10, y: 20 }
print(`  ✓ Object literal: ${obj}`)


let objX: any = obj.x
print(`  ✓ Object property: ${objX}`)


obj.x = 99
print(`  ✓ Object assignment: ${obj}`)


let objY: any = obj["y"]
print(`  ✓ Computed property: ${objY}`)


let propX: int = 100
let propY: int = 200
let shorthand: any = { propX, propY }
print(`  ✓ Object shorthand: ${shorthand}`)


let nestedObj: any = { a: { b: { c: 42 } } }
let nestedVal: any = nestedObj.a.b.c
print(`  ✓ Nested object: ${nestedVal}`)

testsPassed = testsPassed + 6




print("\n[8] CLASSES")


class BasicClass {
    value: int

    constructor(v: int) {
        this.value = v
    }

    getValue(): int {
        return this.value
    }
}
let basicObj: BasicClass = new BasicClass(42)
let classVal: int = basicObj.getValue()
print(`  ✓ Basic class: ${classVal}`)


class PropsClass {
    x: int
    y: int

    constructor(x: int, y: int) {
        this.x = x
        this.y = y
    }
}
let propsObj: PropsClass = new PropsClass(10, 20)
print(`  ✓ Class properties: x=${propsObj.x}, y=${propsObj.y}`)


class MethodsClass {
    value: int

    constructor(v: int) {
        this.value = v
    }

    double(): int {
        return this.value * 2
    }

    add(x: int): int {
        return this.value + x
    }
}
let methodsObj: MethodsClass = new MethodsClass(5)
let doubled: int = methodsObj.double()
let added: int = methodsObj.add(10)
print(`  ✓ Class methods: doubled=${doubled}, added=${added}`)


class ParentClass {
    parentValue: int

    constructor(v: int) {
        this.parentValue = v
    }

    parentMethod(): int {
        return this.parentValue
    }
}

class ChildClass extends ParentClass {
    childValue: int

    constructor(p: int, c: int) {
        super(p)
        this.childValue = c
    }

    childMethod(): int {
        return this.parentValue + this.childValue
    }
}
let childObj: ChildClass = new ChildClass(10, 20)
let inheritVal: int = childObj.childMethod()
print(`  ✓ Class inheritance: ${inheritVal}`)


class StaticClass {
    static staticValue: int = 100

    static staticMethod(): int {
        return StaticClass.staticValue * 2
    }
}
let staticResult: int = StaticClass.staticMethod()
print(`  ✓ Static members: ${staticResult}`)


class PrivateClass {
    private secret: int
    public visible: int

    constructor(s: int, v: int) {
        this.secret = s
        this.visible = v
    }

    getSecret(): int {
        return this.secret
    }
}
let privateObj: PrivateClass = new PrivateClass(42, 99)
let secretVal: int = privateObj.getSecret()
print(`  ✓ Private properties: ${secretVal}`)


class AccessorClass {
    private _value: int

    constructor(v: int) {
        this._value = v
    }

    get value(): int {
        return this._value
    }

    set value(v: int): void {
        this._value = v
    }
}
let accessorObj: AccessorClass = new AccessorClass(10)
let getterVal: int = accessorObj.value
accessorObj.value = 20
print(`  ✓ Getters/Setters: old=${getterVal}, new=${accessorObj.value}`)

testsPassed = testsPassed + 7




print("\n[9] INTERFACES & TYPE ALIASES")


interface IPoint {
    x: int
    y: int
}
let point: IPoint = { x: 10, y: 20 }
print(`  ✓ Basic interface: ${point}`)


interface ICalculator {
    add(a: int, b: int): int
    multiply(a: int, b: int): int
}


class Calculator {
    add(a: int, b: int): int {
        return a + b
    }

    multiply(a: int, b: int): int {
        return a * b
    }
}
let calc: Calculator = new Calculator()
let calcResult: int = calc.add(5, 10)
print(`  ✓ Interface implementation: ${calcResult}`)


type NumberOrString = int | str
let typeAliasNum: NumberOrString = 42
let typeAliasStr: NumberOrString = "hello"
print(`  ✓ Type alias: num=${typeAliasNum}, str=${typeAliasStr}`)


interface INameable {
    name: str
}
interface IPerson extends INameable {
    age: int
}
let person: IPerson = { name: "Alice", age: 30 }
print(`  ✓ Interface extends: ${person}`)

testsPassed = testsPassed + 5




print("\n[10] ENUMS")


enum Status {
    Pending,
    Active,
    Completed,
}
let status: Status = Status.Active
print(`  ✓ Numeric enum: ${status}`)


enum Color {
    Red = "RED",
    Green = "GREEN",
    Blue = "BLUE",
}
let color: Color = Color.Red
print(`  ✓ String enum: ${color}`)


enum Mixed {
    First = 1,
    Second = 2,
    Third = "three",
}
let mixed: Mixed = Mixed.Third
print(`  ✓ Mixed enum: ${mixed}`)

testsPassed = testsPassed + 3




print("\n[11] GENERICS")


fn identity<T>(x: T): T {
    return x
}
let idInt: int = identity<int>(42)
let idStr: str = identity<str>("hello")
print(`  ✓ Generic function: ${idInt}, ${idStr}`)

