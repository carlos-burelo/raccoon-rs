

print("=== EDGE CASES: Sistema de Tipos ===\n");




print("[ 1 ] Valores lÃ­mite de tipos enteros con signo:");

let minI8: i8 = -128;
let maxI8: i8 = 127;
let minI16: i16 = -32768;
let maxI16: i16 = 32767;
let minI32: i32 = -2147483648;
let maxI32: i32 = 2147483647;
let minI64: i64 = -9223372036854775808;
let maxI64: i64 = 9223372036854775807;

print("  âœ“ i8:  " + minI8.toStr() + " a " + maxI8.toStr());
print("  âœ“ i16: " + minI16.toStr() + " a " + maxI16.toStr());
print("  âœ“ i32: " + minI32.toStr() + " a " + maxI32.toStr());
print("  âœ“ i64: " + minI64.toStr() + " a " + maxI64.toStr());

print("\n[ 2 ] Valores lÃ­mite de tipos sin signo:");

let minU8: u8 = 0;
let maxU8: u8 = 255;
let minU16: u16 = 0;
let maxU16: u16 = 65535;
let minU32: u32 = 0;
let maxU32: u32 = 4294967295;
let minU64: u64 = 0;
let maxU64: u64 = 18446744073709551615;

print("  âœ“ u8:  " + minU8.toStr() + " a " + maxU8.toStr());
print("  âœ“ u16: " + minU16.toStr() + " a " + maxU16.toStr());
print("  âœ“ u32: " + minU32.toStr() + " a " + maxU32.toStr());
print("  âœ“ u64: " + minU64.toStr() + " a " + maxU64.toStr());




print("\n[ 3 ] Cadenas de conversiÃ³n widening:");

let start: i8 = 42;
let step1: i16 = start;   
let step2: i32 = step1;   
let step3: i64 = step2;   
let step4: f64 = step3;   
let step5: decimal = step4; 

print("  âœ“ i8 -> i16 -> i32 -> i64 -> f64 -> decimal: " + step5.toStr());


let uStart: u8 = 200;
let uStep1: u16 = uStart; 
let uStep2: u32 = uStep1; 
let uStep3: u64 = uStep2; 
let uStep4: f64 = uStep3; 

print("  âœ“ u8 -> u16 -> u32 -> u64 -> f64: " + uStep4.toStr());


let mixed1: u8 = 100;
let mixed2: i16 = mixed1;  
let mixed3: i64 = mixed2;  
let mixed4: decimal = mixed3; 

print("  âœ“ u8 -> i16 -> i64 -> decimal: " + mixed4.toStr());




print("\n[ 4 ] Operaciones aritmÃ©ticas entre diferentes tipos:");

let op1: i8 = 10;
let op2: i32 = 20;
let result1: i32 = op1 + op2;  
print("  âœ“ i8(10) + i32(20) = i32(" + result1.toStr() + ")");

let op3: i16 = 5;
let op4: i64 = 15;
let result2: i64 = op3 * op4;  
print("  âœ“ i16(5) * i64(15) = i64(" + result2.toStr() + ")");

let op5: u8 = 8;
let op6: u32 = 4;
let result3: u32 = op5 - op6;  
print("  âœ“ u8(8) - u32(4) = u32(" + result3.toStr() + ")");

let op7: f32 = 3.5;
let op8: f64 = 2.0;
let result4: f64 = op7 * op8;  
print("  âœ“ f32(3.5) * f64(2.0) = f64(" + result4.toStr() + ")");

let op9: i32 = 100;
let op10: f32 = 2.5;
let result5: f32 = op9 + op10; 
print("  âœ“ i32(100) + f32(2.5) = f32(" + result5.toStr() + ")");




print("\n[ 5 ] Operaciones bitwise entre tipos enteros:");

let bit1: i8 = 15;   
let bit2: i32 = 240; 
let andResult: i32 = bit1 & bit2;  
print("  âœ“ i8(15) & i32(240) = i32(" + andResult.toStr() + ")");

let bit3: u8 = 12;   
let bit4: u16 = 10;  
let orResult: u16 = bit3 | bit4;   
print("  âœ“ u8(12) | u16(10) = u16(" + orResult.toStr() + ")");

let bit5: i16 = 5;
let bit6: i32 = 3;
let xorResult: i32 = bit5 ^ bit6;  
print("  âœ“ i16(5) ^ i32(3) = i32(" + xorResult.toStr() + ")");

let shift1: i8 = 4;
let shift2: i32 = 2;
let shiftLeft: i32 = shift1 << shift2;  
print("  âœ“ i8(4) << i32(2) = i32(" + shiftLeft.toStr() + ")");

let shift3: i32 = 16;
let shift4: i8 = 2;
let shiftRight: i32 = shift3 >> shift4; 
print("  âœ“ i32(16) >> i8(2) = i32(" + shiftRight.toStr() + ")");




print("\n[ 6 ] Funciones con mÃºltiples tipos de parÃ¡metros:");

fn processI8(x: i8): str {
  return "i8: " + x.toStr();
}

fn processI32(x: i32): str {
  return "i32: " + x.toStr();
}

fn processF64(x: f64): str {
  return "f64: " + x.toStr();
}

fn processDecimal(x: decimal): str {
  return "decimal: " + x.toStr();
}

let val8: i8 = 50;
let val32: i32 = 5000;
let val64: f64 = 50.5;
let valDec: decimal = 50.123456;

print("  âœ“ " + processI8(val8));
print("  âœ“ " + processI32(val32));
print("  âœ“ " + processF64(val64));
print("  âœ“ " + processDecimal(valDec));


print("  âœ“ Sugar type en i8: " + processI8(25));
print("  âœ“ Sugar type en i32: " + processI32(2500));
print("  âœ“ Sugar type en f64: " + processF64(25.5));




print("\n[ 7 ] Arrays con diferentes tipos numÃ©ricos:");

let arrI8: i8[] = [1, 2, 3, 4, 5];
let arrI32: i32[] = [100, 200, 300];
let arrU8: u8[] = [255, 128, 64];
let arrF32: f32[] = [1.1, 2.2, 3.3];
let arrF64: f64[] = [10.5, 20.5, 30.5];

print("  âœ“ i8[]:  " + arrI8.toStr());
print("  âœ“ i32[]: " + arrI32.toStr());
print("  âœ“ u8[]:  " + arrU8.toStr());
print("  âœ“ f32[]: " + arrF32.toStr());
print("  âœ“ f64[]: " + arrF64.toStr());




print("\n[ 8 ] Operaciones con cero y nÃºmeros negativos:");

let zero8: i8 = 0;
let negI8: i8 = -128;
let result8: i8 = zero8 + negI8;
print("  âœ“ i8(0) + i8(-128) = " + result8.toStr());

let negI32: i32 = -1000000;
let posI32: i32 = 1000000;
let sumZero: i32 = negI32 + posI32;
print("  âœ“ i32(-1000000) + i32(1000000) = " + sumZero.toStr());

let negF64: f64 = -3.14159;
let absF64: f64 = negF64 * -1.0;
print("  âœ“ f64(-3.14159) * -1 = " + absF64.toStr());


let posVal: i32 = 42;
let negVal: i32 = -posVal;
print("  âœ“ NegaciÃ³n unaria: -42 = " + negVal.toStr());




print("\n[ 9 ] Conversiones explÃ­citas entre tipos:");

let original: i32 = 256;
print("  Original i32: " + original.toStr());
print("  âœ“ toI8():  " + original.toI8().toStr());
print("  âœ“ toI16(): " + original.toI16().toStr());
print("  âœ“ toI64(): " + original.toI64().toStr());
print("  âœ“ toF32(): " + original.toF32().toStr());
print("  âœ“ toF64(): " + original.toF64().toStr());

let floatVal: f64 = 123.456;
print("  Original f64: " + floatVal.toStr());
print("  âœ“ toInt():     " + floatVal.toInt().toStr());
print("  âœ“ toDecimal(): " + floatVal.toDecimal().toStr());




print("\n[ 10 ] Comparaciones entre diferentes tipos:");

let cmp1: i8 = 10;
let cmp2: i32 = 10;
let eq1: bool = cmp1 == cmp2;
print("  âœ“ i8(10) == i32(10): " + eq1.toStr());

let cmp3: u8 = 50;
let cmp4: i16 = 50;
let eq2: bool = cmp3 == cmp4;
print("  âœ“ u8(50) == i16(50): " + eq2.toStr());

let cmp5: f32 = 3.14;
let cmp6: f64 = 3.14;
let eq3: bool = cmp5 == cmp6;
print("  âœ“ f32(3.14) == f64(3.14): " + eq3.toStr());

let cmp7: i32 = 100;
let cmp8: i64 = 200;
let less: bool = cmp7 < cmp8;
print("  âœ“ i32(100) < i64(200): " + less.toStr());




print("\n[ 11 ] Expresiones complejas con mÃºltiples tipos:");

let expr1: i8 = 2;
let expr2: i16 = 3;
let expr3: i32 = 4;
let expr4: i64 = 5;
let complex1: i64 = expr1 + expr2 * expr3 - expr4;
print("  âœ“ i8(2) + i16(3) * i32(4) - i64(5) = i64(" + complex1.toStr() + ")");

let expr5: u8 = 10;
let expr6: u16 = 20;
let expr7: u32 = 30;
let complex2: u32 = expr5 * expr6 + expr7;
print("  âœ“ u8(10) * u16(20) + u32(30) = u32(" + complex2.toStr() + ")");

let expr8: f32 = 2.5;
let expr9: f64 = 3.0;
let expr10: decimal = 1.5;
let complex3: decimal = expr8 * expr9 + expr10;
print("  âœ“ f32(2.5) * f64(3.0) + decimal(1.5) = decimal(" + complex3.toStr() + ")");




print("\n[ 12 ] Operaciones con arrays de tipos mixtos:");

let mixArr1: i8[] = [1, 2, 3];
let mixArr2: i32[] = [10, 20, 30];
let mixArr3: f64[] = [1.5, 2.5, 3.5];

print("  âœ“ Array i8 length: " + mixArr1.toStr());
print("  âœ“ Array i32 length: " + mixArr2.toStr());
print("  âœ“ Array f64 length: " + mixArr3.toStr());


mixArr1.push(4);
mixArr2.push(40);
mixArr3.push(4.5);

print("  âœ“ DespuÃ©s de push: i8[] = " + mixArr1.toStr());
print("  âœ“ DespuÃ©s de push: i32[] = " + mixArr2.toStr());
print("  âœ“ DespuÃ©s de push: f64[] = " + mixArr3.toStr());




print("\n[ 13 ] Valores decimales de alta precisiÃ³n:");

let dec1: decimal = 0.1;
let dec2: decimal = 0.2;
let dec3: decimal = dec1 + dec2;
print("  âœ“ decimal(0.1) + decimal(0.2) = " + dec3.toStr());

let dec4: decimal = 999999999.123456789;
let dec5: decimal = 0.000000001;
let dec6: decimal = dec4 + dec5;
print("  âœ“ Suma de alta precisiÃ³n: " + dec6.toStr());




print("\n[ 14 ] Funciones recursivas con tipos especÃ­ficos:");

fn factorialI32(n: i32): i32 {
  if (n <= 1) {
    return 1;
  }
  return n * factorialI32(n - 1);
}

fn fibonacciI64(n: i64): i64 {
  if (n <= 1) {
    return n;
  }
  return fibonacciI64(n - 1) + fibonacciI64(n - 2);
}

let fact5: i32 = factorialI32(5);
let fib10: i64 = fibonacciI64(10);

print("  âœ“ factorial(5) = " + fact5.toStr());
print("  âœ“ fibonacci(10) = " + fib10.toStr());




print("\n[ 15 ] Ranges con tipos enteros especÃ­ficos:");

let rangeI8: i8[] = 1..5;
let rangeI32: i32[] = 10..15;
let rangeU8: u8[] = 0..3;

print("  âœ“ Range i8(1..5):   " + rangeI8.toStr());
print("  âœ“ Range i32(10..15): " + rangeI32.toStr());
print("  âœ“ Range u8(0..3):    " + rangeU8.toStr());




print("\n[ 16 ] Operador mÃ³dulo con diferentes tipos:");

let mod1: i8 = 10;
let mod2: i32 = 3;
let modResult1: i32 = mod1 % mod2;
print("  âœ“ i8(10) % i32(3) = i32(" + modResult1.toStr() + ")");

let mod3: u16 = 100;
let mod4: u32 = 7;
let modResult2: u32 = mod3 % mod4;
print("  âœ“ u16(100) % u32(7) = u32(" + modResult2.toStr() + ")");




print("\n==================================================");
print("âœ… TODOS LOS EDGE CASES PASARON EXITOSAMENTE");
print("==================================================");
print("\nTipos probados:");
print("  â€¢ Signed integers: i8, i16, i32, i64");
print("  â€¢ Unsigned integers: u8, u16, u32, u64");
print("  â€¢ Floating point: f32, f64, decimal");
print("  â€¢ Sugar types: int, float");
print("\nOperaciones probadas:");
print("  â€¢ AritmÃ©ticas: +, -, *, /, %");
print("  â€¢ Bitwise: &, |, ^, <<, >>");
print("  â€¢ ComparaciÃ³n: ==, !=, <, >, <=, >=");
print("  â€¢ Widening automÃ¡tico");
print("  â€¢ Conversiones explÃ­citas");
print("  â€¢ Arrays tipados");
print("  â€¢ Funciones recursivas");
print("  â€¢ Ranges");
print("\nðŸŽ‰ Sistema de tipos funcionando perfectamente!");
