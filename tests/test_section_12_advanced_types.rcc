

print("Testing Advanced Types...")


type IntOrStr = int | str
let unionInt: IntOrStr = 42
let unionStr: IntOrStr = "hello"
print(`  ✓ Union types: ${unionInt}, ${unionStr}`)


interface IHasName {
    name: str
}
interface IHasAge {
    age: int
}
type NameAndAge = IHasName & IHasAge
let intersection: NameAndAge = { name: "Bob", age: 25 }
print(`  ✓ Intersection types: ${intersection}`)


let nullable1: int? = 42
let nullable2: int? = null
let nullCheck: bool = nullable1 != null
print(`  ✓ Nullable types: ${nullable1}, ${nullable2}, check=${nullCheck}`)


let intArr: int[] = [1, 2, 3]
let strArr: str[] = ["a", "b"]
let nestedArr: int[][] = [[1, 2], [3, 4]]
print(`  ✓ Array types: int[], str[], int[][]`)


let tuple: [int, str, bool] = [42, "hello", true]
let tupleFirst: int = tuple[0]
let tupleSecond: str = tuple[1]
print(`  ✓ Tuple types: ${tupleFirst}, ${tupleSecond}`)


let objType: { x: int, y: int } = { x: 10, y: 20 }
print(`  ✓ Object types: ${objType}`)


let funcType: (int, int) => int = (a: int, b: int): int => a + b
let funcTypeResult: int = funcType(5, 10)
print(`  ✓ Function types: ${funcTypeResult}`)


type ReadonlyPoint = readonly { x: int, y: int }
let readonlyObj: ReadonlyPoint = { x: 10, y: 20 }
print(`  ✓ Readonly types: ${readonlyObj}`)


interface IUser {
    name: str
    age: int
}
type UserKeys = keyof IUser
print(`  ✓ KeyOf operator: defined`)


let someValue: int = 42
let typeofVal: any = typeof someValue
print(`  ✓ TypeOf operator: ${typeofVal}`)

print("✅ Advanced Types tests completed")
