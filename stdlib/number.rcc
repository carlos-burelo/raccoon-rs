


export fn in_range(n: int, min: int, max: int): bool {
    return n >= min && n <= max;
}


export fn lerp(start: float, end: float, t: float): float {
    return start + (end - start) * t;
}


export fn clamp_float(value: float, min: float, max: float): float {
    if (value < min) return min;
    if (value > max) return max;
    return value;
}


export fn map_range(value: float, in_min: float, in_max: float, out_min: float, out_max: float): float {
    let normalized = (value - in_min) / (in_max - in_min);
    return out_min + normalized * (out_max - out_min);
}


export fn gcd(a: int, b: int): int {
    let abs_a = a;
    if (abs_a < 0) abs_a = -abs_a;

    let abs_b = b;
    if (abs_b < 0) abs_b = -abs_b;

    while (abs_b != 0) {
        let temp = abs_b;
        abs_b = abs_a % abs_b;
        abs_a = temp;
    }

    return abs_a;
}


export fn lcm(a: int, b: int): int {
    if (a == 0 || b == 0) {
        return 0;
    }
    let abs_a = a;
    if (abs_a < 0) abs_a = -abs_a;

    let abs_b = b;
    if (abs_b < 0) abs_b = -abs_b;

    return (abs_a * abs_b) / gcd(a, b);
}


export fn is_prime(n: int): bool {
    if (n <= 1) return false;
    if (n <= 3) return true;
    if (n % 2 == 0 || n % 3 == 0) return false;

    let i = 5;
    while (i * i <= n) {
        if (n % i == 0 || n % (i + 2) == 0) {
            return false;
        }
        i = i + 6;
    }

    return true;
}


export fn factorial(n: int): int {
    if (n < 0) return 0;
    if (n == 0 || n == 1) return 1;

    let result = 1;
    for (let i = 2; i <= n; i = i + 1) {
        result = result * i;
    }

    return result;
}


export fn fibonacci(n: int): int {
    if (n <= 0) return 0;
    if (n == 1) return 1;

    let a = 0;
    let b = 1;

    for (let i = 2; i <= n; i = i + 1) {
        let temp = a + b;
        a = b;
        b = temp;
    }

    return b;
}


export fn range(start: int, end: int): int[] {
    let result: int[] = [];

    if (start <= end) {
        for (let i = start; i <= end; i = i + 1) {
            result.push(i);
        }
    } else {
        for (let i = start; i >= end; i = i - 1) {
            result.push(i);
        }
    }

    return result;
}


export fn range_step(start: int, end: int, step: int): int[] {
    let result: int[] = [];

    if (step == 0) return result;

    if (step > 0) {
        let i = start;
        while (i <= end) {
            result.push(i);
            i = i + step;
        }
    } else {
        let i = start;
        while (i >= end) {
            result.push(i);
            i = i + step;
        }
    }

    return result;
}


export fn average(numbers: float[]): float {
    if (numbers.length == 0) {
        return 0.0;
    }

    let sum = 0.0;
    for (let i = 0; i < numbers.length; i = i + 1) {
        sum = sum + numbers[i];
    }

    return sum / numbers.length;
}


export fn median(numbers: float[]): float {
    let len = numbers.length;
    if (len == 0) {
        return 0.0;
    }

    let sorted = numbers.sort();
    let mid = len / 2;

    if (len % 2 == 0) {
        return (sorted[mid - 1] + sorted[mid]) / 2.0;
    } else {
        return sorted[mid];
    }
}


export fn sum(numbers: float[]): float {
    let total = 0.0;
    for (let i = 0; i < numbers.length; i = i + 1) {
        total = total + numbers[i];
    }
    return total;
}


export fn min(numbers: float[]): float {
    if (numbers.length == 0) {
        return 0.0;
    }

    let minimum = numbers[0];
    for (let i = 1; i < numbers.length; i = i + 1) {
        if (numbers[i] < minimum) {
            minimum = numbers[i];
        }
    }

    return minimum;
}


export fn max(numbers: float[]): float {
    if (numbers.length == 0) {
        return 0.0;
    }

    let maximum = numbers[0];
    for (let i = 1; i < numbers.length; i = i + 1) {
        if (numbers[i] > maximum) {
            maximum = numbers[i];
        }
    }

    return maximum;
}

export default {
    in_range,
    lerp,
    clamp_float,
    map_range,
    gcd,
    lcm,
    is_prime,
    factorial,
    fibonacci,
    range,
    range_step,
    average,
    median,
    sum,
    min,
    max
};
