// Object stdlib - High-level object utilities

/**
 * Gets all keys from an object
 */
export fn keys(obj: object): str[] {
    return native_object_keys(obj);
}

/**
 * Gets all values from an object
 */
export fn values(obj: object): any[] {
    return native_object_values(obj);
}

/**
 * Gets all entries from an object as [key, value] pairs
 */
export fn entries(obj: object): [str, any][] {
    return native_object_entries(obj);
}

/**
 * Checks if object has a specific key
 */
export fn has_key(obj: object, key: str): bool {
    return native_object_has(obj, key);
}

/**
 * Creates a shallow copy of an object
 */
export fn clone(obj: object): object {
    let result = {};
    let obj_keys = keys(obj);

    for (let i = 0; i < native_array_length(obj_keys); i = i + 1) {
        let key = obj_keys[i];
        result[key] = obj[key];
    }

    return result;
}

/**
 * Merges multiple objects into one
 */
export fn merge(objects: object[]): object {
    let result = {};

    for (let i = 0; i < native_array_length(objects); i = i + 1) {
        let obj = objects[i];
        let obj_keys = keys(obj);

        for (let j = 0; j < native_array_length(obj_keys); j = j + 1) {
            let key = obj_keys[j];
            result[key] = obj[key];
        }
    }

    return result;
}

/**
 * Picks specific keys from an object
 */
export fn pick(obj: object, pick_keys: str[]): object {
    let result = {};

    for (let i = 0; i < native_array_length(pick_keys); i = i + 1) {
        let key = pick_keys[i];
        if (has_key(obj, key)) {
            result[key] = obj[key];
        }
    }

    return result;
}

/**
 * Omits specific keys from an object
 */
export fn omit(obj: object, omit_keys: str[]): object {
    let result = {};
    let obj_keys = keys(obj);

    for (let i = 0; i < native_array_length(obj_keys); i = i + 1) {
        let key = obj_keys[i];
        let should_omit = false;

        for (let j = 0; j < native_array_length(omit_keys); j = j + 1) {
            if (key == omit_keys[j]) {
                should_omit = true;
                break;
            }
        }

        if (!should_omit) {
            result[key] = obj[key];
        }
    }

    return result;
}

/**
 * Checks if object is empty (has no keys)
 */
export fn is_empty(obj: object): bool {
    return native_array_length(keys(obj)) == 0;
}

/**
 * Maps over object values
 */
export fn map_values(obj: object, mapper: (value: any, key: str) => any): object {
    let result = {};
    let obj_keys = keys(obj);

    for (let i = 0; i < native_array_length(obj_keys); i = i + 1) {
        let key = obj_keys[i];
        result[key] = mapper(obj[key], key);
    }

    return result;
}

/**
 * Maps over object keys
 */
export fn map_keys(obj: object, mapper: (key: str, value: any) => str): object {
    let result = {};
    let obj_keys = keys(obj);

    for (let i = 0; i < native_array_length(obj_keys); i = i + 1) {
        let key = obj_keys[i];
        let new_key = mapper(key, obj[key]);
        result[new_key] = obj[key];
    }

    return result;
}

/**
 * Filters object by predicate
 */
export fn filter(obj: object, predicate: (value: any, key: str) => bool): object {
    let result = {};
    let obj_keys = keys(obj);

    for (let i = 0; i < native_array_length(obj_keys); i = i + 1) {
        let key = obj_keys[i];
        if (predicate(obj[key], key)) {
            result[key] = obj[key];
        }
    }

    return result;
}

/**
 * Inverts object keys and values
 */
export fn invert(obj: object): object {
    let result = {};
    let obj_keys = keys(obj);

    for (let i = 0; i < native_array_length(obj_keys); i = i + 1) {
        let key = obj_keys[i];
        let value = obj[key];
        result[value] = key;
    }

    return result;
}

export default {
    keys,
    values,
    entries,
    has_key,
    clone,
    merge,
    pick,
    omit,
    is_empty,
    map_values,
    map_keys,
    filter,
    invert
};
