// Object stdlib - High-level object utilities
// Native operations (keys, values, entries, has) are provided by the native module
// Use native_object_keys(), native_object_values(), native_object_entries(), and native_object_has() directly

/**
 * Creates a shallow copy of an object
 */
export fn clone(obj: object): object {
    let result = {};
    let obj_keys = native_object_keys(obj);

    for (let i = 0; i < obj_keys.length; i = i + 1) {
        let key = obj_keys[i];
        result[key] = obj[key];
    }

    return result;
}

/**
 * Merges multiple objects into one
 */
export fn merge(objects: object[]): object {
    let result = {};

    for (let i = 0; i < objects.length; i = i + 1) {
        let obj = objects[i];
        let obj_keys = native_object_keys(obj);

        for (let j = 0; j < obj_keys.length; j = j + 1) {
            let key = obj_keys[j];
            result[key] = obj[key];
        }
    }

    return result;
}

/**
 * Picks specific keys from an object
 */
export fn pick(obj: object, pick_keys: str[]): object {
    let result = {};

    for (let i = 0; i < pick_keys.length; i = i + 1) {
        let key = pick_keys[i];
        if (native_object_has(obj, key)) {
            result[key] = obj[key];
        }
    }

    return result;
}

/**
 * Omits specific keys from an object
 */
export fn omit(obj: object, omit_keys: str[]): object {
    let result = {};
    let obj_keys = native_object_keys(obj);

    for (let i = 0; i < obj_keys.length; i = i + 1) {
        let key = obj_keys[i];
        let should_omit = false;

        for (let j = 0; j < omit_keys.length; j = j + 1) {
            if (key == omit_keys[j]) {
                should_omit = true;
                break;
            }
        }

        if (!should_omit) {
            result[key] = obj[key];
        }
    }

    return result;
}

/**
 * Checks if object is empty (has no keys)
 */
export fn is_empty(obj: object): bool {
    return native_object_keys(obj).length == 0;
}

/**
 * Maps over object values
 */
export fn map_values(obj: object, mapper: (value: any, key: str) => any): object {
    let result = {};
    let obj_keys = native_object_keys(obj);

    for (let i = 0; i < obj_keys.length; i = i + 1) {
        let key = obj_keys[i];
        result[key] = mapper(obj[key], key);
    }

    return result;
}

/**
 * Maps over object keys
 */
export fn map_keys(obj: object, mapper: (key: str, value: any) => str): object {
    let result = {};
    let obj_keys = native_object_keys(obj);

    for (let i = 0; i < obj_keys.length; i = i + 1) {
        let key = obj_keys[i];
        let new_key = mapper(key, obj[key]);
        result[new_key] = obj[key];
    }

    return result;
}

/**
 * Filters object by predicate
 */
export fn filter(obj: object, predicate: (value: any, key: str) => bool): object {
    let result = {};
    let obj_keys = native_object_keys(obj);

    for (let i = 0; i < obj_keys.length; i = i + 1) {
        let key = obj_keys[i];
        if (predicate(obj[key], key)) {
            result[key] = obj[key];
        }
    }

    return result;
}

/**
 * Inverts object keys and values
 */
export fn invert(obj: object): object {
    let result = {};
    let obj_keys = native_object_keys(obj);

    for (let i = 0; i < obj_keys.length; i = i + 1) {
        let key = obj_keys[i];
        let value = obj[key];
        result[value] = key;
    }

    return result;
}

export default {
    clone,
    merge,
    pick,
    omit,
    is_empty,
    map_values,
    map_keys,
    filter,
    invert
};
