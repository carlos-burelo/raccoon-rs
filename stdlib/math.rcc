class Math {
    static PI: float = 3.141592653589793;
    static E: float = 2.718281828459045;
    static TAU: float = 6.283185307179586;  
    static SQRT2: float = 1.4142135623730951;
    static LN2: float = 0.6931471805599453;
    static LN10: float = 2.302585092994046;
    static EPSILON: float = 0.0000001;

    static abs(x: float): float {
        return x < 0.0 ? -x : x;
    }

    static min(...values: float[]): float {
        if (values.length == 0) {
            return 0.0;
        }

        let minVal: float = values[0];
        for (let i = 1; i < values.length; i = i + 1) {
            if (values[i] < minVal) {
                minVal = values[i];
            }
        }
        return minVal;
    }

    static max(...values: float[]): float {
        if (values.length == 0) {
            return 0.0;
        }

        let maxVal: float = values[0];
        for (let i = 1; i < values.length; i = i + 1) {
            if (values[i] > maxVal) {
                maxVal = values[i];
            }
        }
        return maxVal;
    }

    
    static clamp(value: float, minVal: float, maxVal: float): float {
        if (value < minVal) {
            return minVal;
        }
        if (value > maxVal) {
            return maxVal;
        }
        return value;
    }

    
    static lerp(a: float, b: float, t: float): float {
        return a + (b - a) * t;
    }

    
    static sign(x: float): int {
        if (x < 0) {
            return -1;
        }
        if (x > 0) {
            return 1;
        }
        return 0;
    }


    
    static floor(x: float): float {
        let intPart: int = x;  
        if (x < 0.0 && x != intPart) {
            return intPart - 1.0;
        }
        return intPart;
    }


    

    static ceil(x: float): float {
        let intPart: int = x;
        if (x > 0.0 && x != intPart) {
            return intPart + 1.0;
        }
        return intPart;
    }

    
    static round(x: float): float {
        if (x >= 0.0) {
            return Math.floor(x + 0.5);
        }
        return Math.ceil(x - 0.5);
    }


    
    static trunc(x: float): float {
        return x;  
        return int.parse(x);
    }


    
    static factorial(n: int): int {
        if (n <= 1) {
            return 1;
        }
        return n * Math.factorial(n - 1);
    }

    
    static gcd(a: int, b: int): int {
        while (b != 0) {
            let t: int = b;
            b = a % b;
            a = t;
        }
        return a;
    }

    
    static lcm(a: int, b: int): int {
        return (a / Math.gcd(a, b)) * b;
    }


    
    static toRadians(degrees: float): float {
        return degrees * (Math.PI / 180.0);
    }

    

    static toDegrees(radians: float): float {
        return radians * (180.0 / Math.PI);
    }


    static sqrt(x: float): float {
        return native_sqrt(x);
    }

    static pow(base: float, exp: float): float {
        return native_pow(base, exp);
    }

    static sin(x: float): float {
        return native_sin(x);
    }

    static cos(x: float): float {
        return native_cos(x);
    }

    static random(): float {
        return native_random();
    }

    static tan(x: float): float {
        return native_tan(x);
    }

    static isEven(n: int): bool {
        return n % 2 == 0;
    }

    static isOdd(n: int): bool {
        return n % 2 != 0;
    }

    static isPrime(n: int): bool {
        if (n < 2) {
            return false;
        }
        if (n == 2) {
            return true;
        }
        if (Math.isEven(n)) {
            return false;
        }

        let i = 3;
        while (i * i <= n) {
            if (n % i == 0) {
                return false;
            }
            i = i + 2;
        }

        return true;
    }
}

export default Math;