// Math module - Complete implementation using core primitives
// All logic is implemented in Raccoon, only atomic operations are delegated to Rust

import {
    sqrt as core_sqrt,
    cbrt as core_cbrt,
    sin as core_sin,
    cos as core_cos,
    tan as core_tan,
    asin as core_asin,
    acos as core_acos,
    atan as core_atan,
    atan2 as core_atan2,
    sinh as core_sinh,
    cosh as core_cosh,
    tanh as core_tanh,
    exp as core_exp,
    ln as core_ln,
    log10 as core_log10,
    log as core_log,
    floor as core_floor,
    ceil as core_ceil,
    round as core_round,
    trunc as core_trunc,
    abs as core_abs,
    sign as core_sign
} from "std:runtime";

class Math {
    // Mathematical constants
    static PI: float = 3.141592653589793;
    static E: float = 2.718281828459045;
    static TAU: float = 6.283185307179586;
    static SQRT2: float = 1.4142135623730951;
    static SQRT1_2: float = 0.7071067811865476;
    static LN2: float = 0.6931471805599453;
    static LN10: float = 2.302585092994046;
    static LOG2E: float = 1.4426950408889634;
    static LOG10E: float = 0.4342944819032518;
    static EPSILON: float = 0.0000001;

    // ========================================================================
    // Basic Math Functions (delegate to primitives)
    // ========================================================================

    static abs(x: float): float {
        return core_abs(x);
    }

    static sign(x: float): float {
        return core_sign(x);
    }

    static floor(x: float): float {
        return core_floor(x);
    }

    static ceil(x: float): float {
        return core_ceil(x);
    }

    static round(x: float): float {
        return core_round(x);
    }

    static trunc(x: float): float {
        return core_trunc(x);
    }

    static sqrt(x: float): float {
        return core_sqrt(x);
    }

    static cbrt(x: float): float {
        return core_cbrt(x);
    }

    // ========================================================================
    // Power and Exponential Functions
    // ========================================================================

    static pow(base: float, exp: float): float {
        // Handle special cases
        if (exp == 0.0) return 1.0;
        if (base == 0.0) return 0.0;
        if (exp == 1.0) return base;

        // Use exp(exp * ln(base)) for general case
        if (base > 0.0) {
            return core_exp(exp * core_ln(base));
        }

        // For negative base with integer exponent
        let isNegative: bool = false;
        let absBase: float = base;
        if (base < 0.0) {
            absBase = -base;
            isNegative = true;
        }

        let result: float = core_exp(exp * core_ln(absBase));

        // If base is negative and exp is odd integer, result is negative
        if (isNegative) {
            let expInt: int = exp;
            if (exp == expInt && expInt % 2 == 1) {
                return -result;
            }
        }

        return result;
    }

    static exp(x: float): float {
        return core_exp(x);
    }

    static log(x: float): float {
        return core_ln(x);
    }

    static log10(x: float): float {
        return core_log10(x);
    }

    static log2(x: float): float {
        return core_ln(x) / Math.LN2;
    }

    static logBase(x: float, base: float): float {
        return core_log(x, base);
    }

    // ========================================================================
    // Trigonometric Functions
    // ========================================================================

    static sin(x: float): float {
        return core_sin(x);
    }

    static cos(x: float): float {
        return core_cos(x);
    }

    static tan(x: float): float {
        return core_tan(x);
    }

    static asin(x: float): float {
        return core_asin(x);
    }

    static acos(x: float): float {
        return core_acos(x);
    }

    static atan(x: float): float {
        return core_atan(x);
    }

    static atan2(y: float, x: float): float {
        return core_atan2(y, x);
    }

    // ========================================================================
    // Hyperbolic Functions
    // ========================================================================

    static sinh(x: float): float {
        return core_sinh(x);
    }

    static cosh(x: float): float {
        return core_cosh(x);
    }

    static tanh(x: float): float {
        return core_tanh(x);
    }

    static asinh(x: float): float {
        // asinh(x) = ln(x + sqrt(x^2 + 1))
        return core_ln(x + core_sqrt(x * x + 1.0));
    }

    static acosh(x: float): float {
        // acosh(x) = ln(x + sqrt(x^2 - 1))
        return core_ln(x + core_sqrt(x * x - 1.0));
    }

    static atanh(x: float): float {
        // atanh(x) = 0.5 * ln((1 + x) / (1 - x))
        return 0.5 * core_ln((1.0 + x) / (1.0 - x));
    }

    // ========================================================================
    // Angle Conversion
    // ========================================================================

    static toRadians(degrees: float): float {
        return degrees * (Math.PI / 180.0);
    }

    static toDegrees(radians: float): float {
        return radians * (180.0 / Math.PI);
    }

    // ========================================================================
    // Min/Max and Clamping
    // ========================================================================

    static min(...values: float[]): float {
        if (values.length == 0) {
            return 0.0;
        }

        let minVal: float = values[0];
        for (let i = 1; i < values.length; i = i + 1) {
            if (values[i] < minVal) {
                minVal = values[i];
            }
        }
        return minVal;
    }

    static max(...values: float[]): float {
        if (values.length == 0) {
            return 0.0;
        }

        let maxVal: float = values[0];
        for (let i = 1; i < values.length; i = i + 1) {
            if (values[i] > maxVal) {
                maxVal = values[i];
            }
        }
        return maxVal;
    }

    static clamp(value: float, minVal: float, maxVal: float): float {
        if (value < minVal) return minVal;
        if (value > maxVal) return maxVal;
        return value;
    }

    // ========================================================================
    // Interpolation and Utilities
    // ========================================================================

    static lerp(a: float, b: float, t: float): float {
        return a + (b - a) * t;
    }

    static hypot(x: float, y: float): float {
        return core_sqrt(x * x + y * y);
    }

    static fract(x: float): float {
        return x - core_floor(x);
    }

    // ========================================================================
    // Integer Math Functions
    // ========================================================================

    static factorial(n: int): int {
        if (n <= 1) {
            return 1;
        }
        let result: int = 1;
        for (let i = 2; i <= n; i = i + 1) {
            result = result * i;
        }
        return result;
    }

    static gcd(a: int, b: int): int {
        let absA: int = a < 0 ? -a : a;
        let absB: int = b < 0 ? -b : b;

        while (absB != 0) {
            let temp: int = absB;
            absB = absA % absB;
            absA = temp;
        }
        return absA;
    }

    static lcm(a: int, b: int): int {
        if (a == 0 || b == 0) {
            return 0;
        }
        let absA: int = a < 0 ? -a : a;
        let absB: int = b < 0 ? -b : b;
        return (absA / Math.gcd(absA, absB)) * absB;
    }

    static isEven(n: int): bool {
        return n % 2 == 0;
    }

    static isOdd(n: int): bool {
        return n % 2 != 0;
    }

    static isPrime(n: int): bool {
        if (n < 2) {
            return false;
        }
        if (n == 2) {
            return true;
        }
        if (Math.isEven(n)) {
            return false;
        }

        let i: int = 3;
        while (i * i <= n) {
            if (n % i == 0) {
                return false;
            }
            i = i + 2;
        }

        return true;
    }

    // ========================================================================
    // Floating Point Utilities
    // ========================================================================

    static isNaN(x: float): bool {
        return x != x;
    }

    static isFinite(x: float): bool {
        return !Math.isNaN(x) && x != 1.0 / 0.0 && x != -1.0 / 0.0;
    }

    static approxEqual(a: float, b: float, epsilon: float): bool {
        return core_abs(a - b) < epsilon;
    }

    static approxEqualDefault(a: float, b: float): bool {
        return Math.approxEqual(a, b, Math.EPSILON);
    }
}

export default Math;
