export fn length<T>(arr: T[]): int {
    return arr.length;
}


export fn push<T>(arr: T[], item: T): void {
    arr.push(item);
}


export fn pop<T>(arr: T[]): T {
    return arr.pop();
}


export fn shift<T>(arr: T[]): T {
    return arr.shift();
}


export fn unshift<T>(arr: T[], item: T): void {
    arr.unshift(item);
}


export fn slice<T>(arr: T[], start: int, end: int): T[] {
    return arr.slice(start, end);
}


export fn reverse<T>(arr: T[]): T[] {
    return arr.reverse();
}


export fn sort<T>(arr: T[]): T[] {
    return arr.sort();
}


export fn map<T, R>(arr: T[], callback: (item: T, index: int) => R): R[] {
    let result: R[] = [];
    for (let i = 0; i < length(arr); i = i + 1) {
        push(result, callback(arr[i], i));
    }
    return result;
}


export fn filter<T>(arr: T[], predicate: (item: T, index: int) => bool): T[] {
    let result: T[] = [];
    for (let i = 0; i < length(arr); i = i + 1) {
        if (predicate(arr[i], i)) {
            push(result, arr[i]);
        }
    }
    return result;
}


export fn reduce<T, R>(arr: T[], callback: (acc: R, item: T, index: int) => R, initial: R): R {
    let accumulator = initial;
    for (let i = 0; i < length(arr); i = i + 1) {
        accumulator = callback(accumulator, arr[i], i);
    }
    return accumulator;
}


export fn some<T>(arr: T[], predicate: (item: T, index: int) => bool): bool {
    for (let i = 0; i < length(arr); i = i + 1) {
        if (predicate(arr[i], i)) {
            return true;
        }
    }
    return false;
}


export fn every<T>(arr: T[], predicate: (item: T, index: int) => bool): bool {
    for (let i = 0; i < length(arr); i = i + 1) {
        if (!predicate(arr[i], i)) {
            return false;
        }
    }
    return true;
}


export fn find<T>(arr: T[], predicate: (item: T, index: int) => bool): T | null {
    for (let i = 0; i < length(arr); i = i + 1) {
        if (predicate(arr[i], i)) {
            return arr[i];
        }
    }
    return null;
}


export fn findIndex<T>(arr: T[], predicate: (item: T, index: int) => bool): int {
    for (let i = 0; i < length(arr); i = i + 1) {
        if (predicate(arr[i], i)) {
            return i;
        }
    }
    return -1;
}


export fn includes<T>(arr: T[], item: T): bool {
    for (let i = 0; i < length(arr); i = i + 1) {
        if (arr[i] == item) {
            return true;
        }
    }
    return false;
}


export fn join<T>(arr: T[], separator: str): str {
    if (length(arr) == 0) {
        return "";
    }

    let result: str = "" + arr[0];
    for (let i = 1; i < length(arr); i = i + 1) {
        result = result + separator + arr[i];
    }
    return result;
}

export fn first<T>(arr: T[]): T | null {
    if (length(arr) == 0) {
        return null;
    }
    return arr[0];
}

export fn last<T>(arr: T[]): T | null {
    let len = length(arr);
    if (len == 0) {
        return null;
    }
    return arr[len - 1];
}

export fn isEmpty<T>(arr: T[]): bool {
    return length(arr) == 0;
}

export fn take<T>(arr: T[], n: int): T[] {
    return slice(arr, 0, n);
}

export fn drop<T>(arr: T[], n: int): T[] {
    return slice(arr, n, length(arr));
}

export fn chunk<T>(arr: T[], size: int): T[][] {
    let result: T[][] = [];
    let len = length(arr);

    for (let i = 0; i < len; i = i + size) {
        let end = i + size;
        if (end > len) {
            end = len;
        }
        push(result, slice(arr, i, end));
    }

    return result;
}

export fn flatten<T>(arr: T[][]): T[] {
    let result: T[] = [];
    for (let i = 0; i < length(arr); i = i + 1) {
        let inner = arr[i];
        for (let j = 0; j < length(inner); j = j + 1) {
            push(result, inner[j]);
        }
    }
    return result;
}

export fn unique<T>(arr: T[]): T[] {
    let result: T[] = [];
    for (let i = 0; i < length(arr); i = i + 1) {
        if (!includes(result, arr[i])) {
            push(result, arr[i]);
        }
    }
    return result;
}

export fn partition<T>(arr: T[], predicate: (item: T, index: int) => bool): [T[], T[]] {
    let truthy: T[] = [];
    let falsy: T[] = [];

    for (let i = 0; i < length(arr); i = i + 1) {
        if (predicate(arr[i], i)) {
            push(truthy, arr[i]);
        } else {
            push(falsy, arr[i]);
        }
    }

    return [truthy, falsy];
}

export fn zip<T, U>(arr1: T[], arr2: U[]): [T, U][] {
    let result: [T, U][] = [];
    let minLen = length(arr1);
    let len2 = length(arr2);

    if (len2 < minLen) {
        minLen = len2;
    }

    for (let i = 0; i < minLen; i = i + 1) {
        push(result, [arr1[i], arr2[i]]);
    }

    return result;
}

export fn compact<T>(arr: T[]): T[] {
    let result: T[] = [];
    for (let i = 0; i < length(arr); i = i + 1) {
        if (arr[i] != null) {
            push(result, arr[i]);
        }
    }
    return result;
}

export default {
    length,
    push,
    pop,
    shift,
    unshift,
    slice,
    reverse,
    sort,
    map,
    filter,
    reduce,
    some,
    every,
    find,
    findIndex,
    includes,
    join,
    first,
    last,
    isEmpty,
    take,
    drop,
    chunk,
    flatten,
    unique,
    partition,
    zip,
    compact
}