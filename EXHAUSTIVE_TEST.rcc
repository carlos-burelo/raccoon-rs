// ╔══════════════════════════════════════════════════════════════╗
// ║  EXHAUSTIVE RACCOON LANGUAGE TEST                           ║
// ║  Testing ALL language features comprehensively              ║
// ╚══════════════════════════════════════════════════════════════╝

print("╔══════════════════════════════════════════════════════════════╗");
print("║  EXHAUSTIVE RACCOON LANGUAGE TEST                           ║");
print("╚══════════════════════════════════════════════════════════════╝");
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 1: PATTERN MATCHING
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 1: PATTERN MATCHING ═══");
try {
    // Switch with different types
    fn testSwitch(value: any): str {
        switch (value) {
            case 1:
                return "one";
            case 2:
                return "two";
            case "hello":
                return "greeting";
            default:
                return "unknown";
        }
    }

    print("✓ Switch with int:", testSwitch(1));
    print("✓ Switch with string:", testSwitch("hello"));
    print("✓ Switch default:", testSwitch(999));
} catch (e) {
    print("✗ Pattern matching failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 2: ALL ARROW FUNCTION SYNTAXES
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 2: ARROW FUNCTION SYNTAXES ═══");
try {
    // Single parameter, no parentheses, expression body
    const single = x => x * 2;
    print("✓ Single param (x => x*2):", single(5));

    // Single parameter with parentheses
    const singleParen = (x) => x * 3;
    print("✓ Single param with parens:", singleParen(5));

    // Multiple parameters
    const multi = (x, y) => x + y;
    print("✓ Multiple params:", multi(10, 20));

    // No parameters
    const noParams = () => 42;
    print("✓ No params:", noParams());

    // Block body
    const block = (x) => {
        const temp = x * 2;
        return temp + 1;
    };
    print("✓ Block body:", block(10));

    // Arrow function returning object
    const returnObj = (name) => ({ name: name, age: 30 });
    const obj = returnObj("Alice");
    print("✓ Return object:", obj.name);

    // Nested arrow functions
    const nested = x => y => x + y;
    print("✓ Nested arrows:", nested(5)(10));

} catch (e) {
    print("✗ Arrow function syntax failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 3: FUNCTION PARAMETERS - ALL TYPES
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 3: FUNCTION PARAMETERS ═══");
try {
    // Default parameters
    fn withDefaults(a: int, b: int = 10, c: int = 20): int {
        return a + b + c;
    }
    print("✓ Default params (all):", withDefaults(1, 2, 3));
    print("✓ Default params (partial):", withDefaults(1, 2));
    print("✓ Default params (minimal):", withDefaults(1));

    // Rest parameters
    fn sumAll(...numbers: int[]): int {
        let total = 0;
        for (let i = 0; i < len(numbers); i = i + 1) {
            total = total + numbers[i];
        }
        return total;
    }
    print("✓ Rest params:", sumAll(1, 2, 3, 4, 5));

    // Mixed: normal + default + rest
    fn mixed(required: int, optional: int = 5, ...rest: int[]): int {
        let sum = required + optional;
        for (let i = 0; i < len(rest); i = i + 1) {
            sum = sum + rest[i];
        }
        return sum;
    }
    print("✓ Mixed params:", mixed(10, 20, 1, 2, 3));

} catch (e) {
    print("✗ Function parameters failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 4: SCOPE AND CLOSURES
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 4: SCOPE AND CLOSURES ═══");
try {
    // Lexical scope
    let outer = 10;
    {
        let inner = 20;
        print("✓ Inner scope access:", outer + inner);
    }

    // Closure capturing
    fn makeCounter(): fn {
        let count = 0;
        return () => {
            count = count + 1;
            return count;
        };
    }
    const counter = makeCounter();
    print("✓ Closure call 1:", counter());
    print("✓ Closure call 2:", counter());
    print("✓ Closure call 3:", counter());

    // Closure with parameter
    fn makeMultiplier(factor: int): fn {
        return (x) => x * factor;
    }
    const times3 = makeMultiplier(3);
    print("✓ Closure with param:", times3(7));

    // Nested closures
    fn outer_fn(x: int): fn {
        return (y) => {
            return (z) => x + y + z;
        };
    }
    print("✓ Nested closures:", outer_fn(1)(2)(3));

} catch (e) {
    print("✗ Scope and closures failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 5: WHILE LOOPS AND DO-WHILE
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 5: WHILE LOOPS ═══");
try {
    // Basic while
    let i = 0;
    let sum = 0;
    while (i < 5) {
        sum = sum + i;
        i = i + 1;
    }
    print("✓ While loop sum(0..4):", sum);

    // While with break
    let j = 0;
    let breakSum = 0;
    while (true) {
        if (j >= 5) {
            break;
        }
        breakSum = breakSum + j;
        j = j + 1;
    }
    print("✓ While with break:", breakSum);

    // While with continue
    let k = 0;
    let continueSum = 0;
    while (k < 10) {
        k = k + 1;
        if (k % 2 == 0) {
            continue;
        }
        continueSum = continueSum + k;
    }
    print("✓ While with continue (odds):", continueSum);

} catch (e) {
    print("✗ While loops failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 6: RANGE LITERALS
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 6: RANGE LITERALS ═══");
try {
    // Exclusive range
    let exclusiveSum = 0;
    for (let n in 1..5) {
        exclusiveSum = exclusiveSum + n;
    }
    print("✓ Exclusive range 1..5:", exclusiveSum);

    // Inclusive range
    let inclusiveSum = 0;
    for (let n in 1..=5) {
        inclusiveSum = inclusiveSum + n;
    }
    print("✓ Inclusive range 1..=5:", inclusiveSum);

} catch (e) {
    print("✗ Range literals failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 7: CLASS INHERITANCE AND SUPER
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 7: CLASS INHERITANCE ═══");
try {
    class Animal {
        constructor(name: str) {
            this.name = name;
        }

        speak(): str {
            return this.name + " makes a sound";
        }
    }

    class Dog extends Animal {
        constructor(name: str, breed: str) {
            super(name);
            this.breed = breed;
        }

        speak(): str {
            return this.name + " barks!";
        }

        getInfo(): str {
            return this.name + " is a " + this.breed;
        }
    }

    const dog = new Dog("Rex", "Labrador");
    print("✓ Inheritance - name:", dog.name);
    print("✓ Inheritance - breed:", dog.breed);
    print("✓ Method override:", dog.speak());
    print("✓ Subclass method:", dog.getInfo());

} catch (e) {
    print("✗ Class inheritance failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 8: DECORATORS
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 8: DECORATORS ═══");
try {
    @sealed
    class DecoratedClass {
        constructor(value: int) {
            this.value = value;
        }
    }

    const decorated = new DecoratedClass(42);
    print("✓ Decorated class:", decorated.value);

    // Method decorators
    class WithMethodDecorator {
        @deprecated
        oldMethod(): str {
            return "old method";
        }

        newMethod(): str {
            return "new method";
        }
    }

    const withDec = new WithMethodDecorator();
    print("✓ Method decorator:", withDec.newMethod());

} catch (e) {
    print("✗ Decorators failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 9: SPREAD AND REST IN DIFFERENT CONTEXTS
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 9: SPREAD/REST OPERATORS ═══");
try {
    // Array spread
    const arr1 = [1, 2, 3];
    const arr2 = [4, 5, 6];
    const combined = [...arr1, ...arr2];
    print("✓ Array spread:", combined);

    // Object spread
    const obj1 = { a: 1, b: 2 };
    const obj2 = { c: 3, d: 4 };
    const objCombined = { ...obj1, ...obj2 };
    print("✓ Object spread:", objCombined.a, objCombined.c);

    // Spread in function call
    fn sum3(a: int, b: int, c: int): int {
        return a + b + c;
    }
    const nums = [10, 20, 30];
    print("✓ Spread in call:", sum3(...nums));

    // Rest in destructuring
    const [first, second, ...rest] = [1, 2, 3, 4, 5];
    print("✓ Rest in destructuring:", first, second, rest);

} catch (e) {
    print("✗ Spread/Rest operators failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 10: TRY/CATCH/FINALLY COMPLETE
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 10: ERROR HANDLING (TRY/CATCH/FINALLY) ═══");
try {
    let finallyExecuted = false;

    try {
        print("✓ Try block executed");
        throw "test error";
    } catch (e) {
        print("✓ Catch block executed:", e);
    } finally {
        finallyExecuted = true;
        print("✓ Finally block executed");
    }

    print("✓ Finally flag:", finallyExecuted);

} catch (e) {
    print("✗ Error handling failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 11: ASYNC/AWAIT IN DIFFERENT CONTEXTS
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 11: ASYNC/AWAIT ═══");
try {
    // Async function
    async fn fetchData(): str {
        return "async data";
    }

    // Await in variable
    const data = await fetchData();
    print("✓ Async function:", data);

    // Future.resolve
    const resolved = await Future.resolve(42);
    print("✓ Future.resolve:", resolved);

    // Future.reject with catch
    try {
        await Future.reject("error message");
    } catch (e) {
        print("✓ Future.reject caught:", e);
    }

    // Future.all
    const futures = [Future.resolve(1), Future.resolve(2), Future.resolve(3)];
    const allResults = await Future.all(futures);
    print("✓ Future.all:", allResults);

} catch (e) {
    print("✗ Async/await failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 12: OBJECT FEATURES (COMPUTED PROPERTIES, SHORTHAND)
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 12: OBJECT FEATURES ═══");
try {
    // Property shorthand
    const name = "Alice";
    const age = 30;
    const person = { name, age };
    print("✓ Property shorthand:", person.name, person.age);

    // Method shorthand
    const objWithMethod = {
        value: 10,
        getValue() {
            return this.value;
        }
    };
    print("✓ Method shorthand:", objWithMethod.getValue());

    // Computed property names
    const key = "dynamic";
    const objComputed = {
        [key]: "value",
        ["key" + "2"]: "value2"
    };
    print("✓ Computed properties:", objComputed.dynamic, objComputed.key2);

} catch (e) {
    print("✗ Object features failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 13: TYPEOF AND INSTANCEOF
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 13: TYPE OPERATORS ═══");
try {
    print("✓ typeof int:", typeof 42);
    print("✓ typeof str:", typeof "hello");
    print("✓ typeof bool:", typeof true);
    print("✓ typeof array:", typeof [1, 2, 3]);
    print("✓ typeof object:", typeof { a: 1 });
    print("✓ typeof function:", typeof (() => 1));

    // instanceof
    class TestClass {}
    const instance = new TestClass();
    print("✓ instanceof:", typeof instance);

} catch (e) {
    print("✗ Type operators failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 14: FOR-IN AND FOR-OF LOOPS
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 14: FOR-IN AND FOR-OF ═══");
try {
    // For-in with array
    const arr = [10, 20, 30];
    let forInSum = 0;
    for (let val in arr) {
        forInSum = forInSum + val;
    }
    print("✓ For-in array:", forInSum);

    // For-in with range
    let rangeSum = 0;
    for (let i in 1..5) {
        rangeSum = rangeSum + i;
    }
    print("✓ For-in range:", rangeSum);

} catch (e) {
    print("✗ For-in/for-of failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 15: BREAK AND CONTINUE IN NESTED LOOPS
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 15: BREAK/CONTINUE IN NESTED LOOPS ═══");
try {
    let nestedCount = 0;
    for (let i = 0; i < 3; i = i + 1) {
        for (let j = 0; j < 3; j = j + 1) {
            if (j == 1) {
                continue;
            }
            nestedCount = nestedCount + 1;
        }
    }
    print("✓ Nested with continue:", nestedCount);

    let breakNested = 0;
    for (let i = 0; i < 5; i = i + 1) {
        for (let j = 0; j < 5; j = j + 1) {
            if (i == 2 && j == 2) {
                break;
            }
            breakNested = breakNested + 1;
        }
    }
    print("✓ Nested with break:", breakNested);

} catch (e) {
    print("✗ Nested break/continue failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 16: ARRAY METHODS (COMPREHENSIVE)
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 16: ARRAY METHODS (COMPREHENSIVE) ═══");
try {
    const testArr = [1, 2, 3, 4, 5];

    // Map
    const mapped = testArr.map(x => x * 2);
    print("✓ Array.map:", mapped);

    // Filter
    const filtered = testArr.filter(x => x > 2);
    print("✓ Array.filter:", filtered);

    // Reduce
    const reduced = testArr.reduce((acc, x) => acc + x, 0);
    print("✓ Array.reduce:", reduced);

    // Find
    const found = testArr.find(x => x > 3);
    print("✓ Array.find:", found);

    // Every
    const allPositive = testArr.every(x => x > 0);
    print("✓ Array.every:", allPositive);

    // Some
    const hasEven = testArr.some(x => x % 2 == 0);
    print("✓ Array.some:", hasEven);

    // ForEach
    let forEachSum = 0;
    testArr.forEach(x => {
        forEachSum = forEachSum + x;
    });
    print("✓ Array.forEach:", forEachSum);

} catch (e) {
    print("✗ Array methods failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 17: STRING METHODS AND TEMPLATE LITERALS
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 17: STRING FEATURES ═══");
try {
    const str = "Hello World";

    // Template literals
    const name = "Alice";
    const age = 30;
    const template = `Name: ${name}, Age: ${age}`;
    print("✓ Template literal:", template);

    // Multi-line template
    const multiline = `Line 1
Line 2
Line 3`;
    print("✓ Multi-line template:", len(multiline) > 15);

    // Template with expressions
    const expr = `Sum: ${10 + 20}`;
    print("✓ Template with expression:", expr);

} catch (e) {
    print("✗ String features failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 18: TERNARY OPERATOR AND SHORT-CIRCUIT
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 18: TERNARY AND SHORT-CIRCUIT ═══");
try {
    // Ternary
    const x = 10;
    const ternary = x > 5 ? "greater" : "less";
    print("✓ Ternary operator:", ternary);

    // Nested ternary
    const val = 15;
    const nested = val < 10 ? "small" : val < 20 ? "medium" : "large";
    print("✓ Nested ternary:", nested);

    // Short-circuit AND
    let andExecuted = false;
    const shortAnd = false && (andExecuted = true);
    print("✓ Short-circuit AND:", !andExecuted);

    // Short-circuit OR
    let orExecuted = false;
    const shortOr = true || (orExecuted = true);
    print("✓ Short-circuit OR:", !orExecuted);

} catch (e) {
    print("✗ Ternary/short-circuit failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 19: NULLISH COALESCING AND OPTIONAL CHAINING
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 19: NULLISH AND OPTIONAL CHAINING ═══");
try {
    // Nullish coalescing
    const nullVal = null;
    const result = nullVal ?? "default";
    print("✓ Nullish coalescing:", result);

    const zeroVal = 0;
    const zeroResult = zeroVal ?? "default";
    print("✓ Nullish with 0:", zeroResult);

    // Optional chaining
    const obj = { a: { b: { c: 42 } } };
    const chained = obj?.a?.b?.c;
    print("✓ Optional chaining (exists):", chained);

    const missing = obj?.x?.y?.z;
    print("✓ Optional chaining (missing):", missing);

} catch (e) {
    print("✗ Nullish/optional chaining failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 20: PRIMITIVE TYPE STATIC METHODS
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 20: PRIMITIVE TYPE METHODS ═══");
try {
    // int methods
    const parsed = int.parse("123");
    print("✓ int.parse:", parsed);
    print("✓ int.MAX_VALUE:", typeof int.MAX_VALUE);
    print("✓ int.MIN_VALUE:", typeof int.MIN_VALUE);

    // float methods
    const floatParsed = float.parse("3.14");
    print("✓ float.parse:", floatParsed);
    print("✓ float.MAX_VALUE:", typeof float.MAX_VALUE);
    print("✓ float.NaN:", typeof float.NaN);

    // str methods
    const charCode = str.fromCharCode(65);
    print("✓ str.fromCharCode:", charCode);

} catch (e) {
    print("✗ Primitive type methods failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 21: OBJECT BUILTIN METHODS
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 21: OBJECT BUILTIN METHODS ═══");
try {
    const testObj = { a: 1, b: 2, c: 3 };

    // Object.keys
    const keys = Object.keys(testObj);
    print("✓ Object.keys:", keys);

    // Object.values
    const values = Object.values(testObj);
    print("✓ Object.values:", values);

    // Object.entries
    const entries = Object.entries(testObj);
    print("✓ Object.entries:", entries);

    // Object.assign
    const target = { x: 10 };
    const source = { y: 20 };
    const assigned = Object.assign(target, source);
    print("✓ Object.assign:", assigned.x, assigned.y);

} catch (e) {
    print("✗ Object builtin methods failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 22: ENUM FEATURES
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 22: ENUM FEATURES ═══");
try {
    enum Color {
        Red,
        Green,
        Blue
    }

    print("✓ Enum typeof:", typeof Color);
    print("✓ Enum.Red:", Color.Red);
    print("✓ Enum.Green:", Color.Green);
    print("✓ Enum.Blue:", Color.Blue);

    // Enum with values
    enum Status {
        Active = 1,
        Inactive = 0,
        Pending = 2
    }

    print("✓ Enum with values:", Status.Active, Status.Inactive);

} catch (e) {
    print("✗ Enum features failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 23: CLASS STATIC METHODS AND PROPERTIES
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 23: CLASS STATICS ═══");
try {
    class MathHelper {
        static PI: float = 3.14159;
        static E: float = 2.71828;

        static add(a: int, b: int): int {
            return a + b;
        }

        static multiply(a: int, b: int): int {
            return a * b;
        }
    }

    print("✓ Static property PI:", MathHelper.PI);
    print("✓ Static property E:", MathHelper.E);
    print("✓ Static method add:", MathHelper.add(10, 20));
    print("✓ Static method multiply:", MathHelper.multiply(5, 6));

} catch (e) {
    print("✗ Class statics failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 24: GETTERS AND SETTERS
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 24: GETTERS AND SETTERS ═══");
try {
    class Rectangle {
        constructor(width: int, height: int) {
            this._width = width;
            this._height = height;
        }

        get area(): int {
            return this._width * this._height;
        }

        set width(w: int) {
            this._width = w;
        }

        get width(): int {
            return this._width;
        }
    }

    const rect = new Rectangle(10, 20);
    print("✓ Getter area:", rect.area);
    rect.width = 15;
    print("✓ Setter width:", rect.width);
    print("✓ Updated area:", rect.area);

} catch (e) {
    print("✗ Getters/setters failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// TEST 25: COMPLEX DESTRUCTURING
// ═══════════════════════════════════════════════════════════════
print("═══ TEST 25: COMPLEX DESTRUCTURING ═══");
try {
    // Nested object destructuring
    const nested = {
        user: {
            name: "Alice",
            address: {
                city: "NYC",
                zip: 10001
            }
        }
    };
    const { user: { name, address: { city } } } = nested;
    print("✓ Nested destructuring:", name, city);

    // Array of objects destructuring
    const users = [
        { id: 1, name: "Bob" },
        { id: 2, name: "Charlie" }
    ];
    const [{ name: firstName }, { name: secondName }] = users;
    print("✓ Array of objects:", firstName, secondName);

    // Default values in destructuring
    const { x = 10, y = 20 } = { x: 5 };
    print("✓ Destructuring with defaults:", x, y);

} catch (e) {
    print("✗ Complex destructuring failed:", e);
}
print("");

// ═══════════════════════════════════════════════════════════════
// FINAL SUMMARY
// ═══════════════════════════════════════════════════════════════
print("╔══════════════════════════════════════════════════════════════╗");
print("║  EXHAUSTIVE TEST SUITE COMPLETED                            ║");
print("║  Check output above for any failures                        ║");
print("╚══════════════════════════════════════════════════════════════╝");
